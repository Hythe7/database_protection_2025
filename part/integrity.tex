\section{Механизмы обеспечения целостности СУБД}

\subsection{Угрозы целостности СУБД}
Задача обеспечения целостности предусматривает комплекс мер по предотвращению как непреднамеренного, так и преднамеренного изменения или уничтожения информации, используемой информационной системой управления или системой поддержки принятия решений. Изменение или уничтожение данных может быть следствием неблагоприятного стечения обстоятельств и состояния внешней среды (стихийные бедствия, пожары и т. п.), аппаратных или программных сбоев (отказ дисковой системы, нарушение целостности файлов БД, ошибки ПО), а также неадекватных действий пользователей (ошибки при вводе данных, ошибки операторов и т. п.) и проблем, возникающих при некорректной организации многопользовательской обработки данных, таких как некорректное управление конкурентным доступом, отсутствие механизмов блокировки и контроля изоляции транзакций. \autocite{Lihonosov2011, postgredoc1}.

Кроме того, угрозу целостности представляют преднамеренные атаки, например: SQL-инъекции, модификация данных привилегированными пользователями, эксплуатация уязвимостей в механизмах контроля доступа. Целостность данных также может быть нарушена в результате физического повреждения носителей информации (износ SSD/HDD, сбои в RAID-массивах, ошибки в системе хранения).

Например, при отсутствии механизмов контроля доступа, с помощью SQL-операторов UPDATE, INSERT и DELETE, злоумышленник или просто неопытный пользователь могут изменить данные в СУБД. Опасность заключается в том, что, при отсутствии принципа минимально необходимых привилегий, пользователь может получить возможность модифицировать все записи в таблице.  \autocite{Utebov2008, nist80012}.

\paragraph{Основные виды и причины возникновения угроз целостности} ~\\

Нарушение целостности информационной системы может произойти по разным причинам (включая технические сбои, ошибки конфигурирования, неправильные действия пользователя, преднамеренные атаки), и некоторые из этих причин могут также приводить и к нарушению доступности информации. \autocite{Pirogov2009}
Эти факторы можно разделить на внутренние (возникающие в результате ошибок эксплуатации или ПО) и внешние (обусловленные воздействием окружающего мира, злоумышленников, технических сбоев) \autocites{IntuitThreats, HabrCloudThreats, WikiExploit, KasperskyDailyOAuth}:

\begin{enumerate}
\item \textbf{Внутренние угрозы целостности ИС}.
    \begin{itemize}
        \item Случайное или умышленное отступление от правил эксплуатации. Например, правила могут предусматривать определенный набор параметров сервера (объем памяти, производительность процессора, объем дискового пространства, версия операционной системы и т.п.), на котором предполагается использовать ИС. Сюда же можно отнести, например, некорректную настройку резервного копирования или преднамеренное отключение логирования.;
        \item Ошибки конфигурирования системы на этапах установки, обновления, эксплуатации. Например, неправильное (необдуманное) управление правами доступа, незащищенные сетевые интерфейсы и т.д.
        \item Отказ программного обеспечения. Может быть вызван ошибками разработки, какими-то некорректными обновлениями, ну или преднамеренными изменениями кода (например, внедрение вредоносного ПО).
	    \item Проблемы управления многопользовательским доступом (состояния гонки, deadlock-ситуации, аномалии уровнеий изоляции транзакций).
    \end{itemize}

\item \textbf{Внешние угрозы целостности ИС}.
    \begin{itemize}
        \item Нарушение условий работы ИС, вызванные сбоями облачных сервисов и/или являющееся следствием зависимости от сторонних провайдеров (проблемы с системами связи, отключения электропитания, отопления и т.п.).
        \item Разрушение или повреждение помещений, связанное с природными катаклизмами. Конечно, такая ситуация на первый взгляд кажется мало возможной, но это вполне вероятно в регионах, например, с сейсмической неустойчивостью (привет Камчатке).
        \item Разрушение информации преднамеренными действиями злоумышленников или инсайдеров.
        \item Сетевые атаки, вредоносные программы (к примеру, шифровальщики, модифицирующие данные), SQL-инъекции, атаки на механизмы репликации и т.д.
	\item Эксплуатация уязвимостей в СУБД, физический доступ к оборудованию.
    \end{itemize}
\end{enumerate}

\paragraph{Способы противодействия} ~\\

Основными средствами защиты целостности информации в ИС являются \autocite{Pirogov2009}:
\begin{itemize}
    \item Транзакционные механизмы, позволяющие восстановить целостность данных в случае незначительных сбоев, ACID-свойства. \autocite{worksol1, DBtest};
    \item Контроль целостности на уровне базы данных. Реализация CHECK, FOREIGN KEY, NOT NULL и триггеров, предтовращающих некорректное изменение данных. \autocite{flenovinfo};
    \item Использование WAL (Write-Ahead Logging) - позволят сохранить изменение перед его внесением в основную базу. То есть проще сделать откат транзакции и восстановление данных. \autocite{WALintro};
    \item Резервное копирование данных. Использование PITR (point-in-time recovery), географически распределеная репликация на случай какого-то серьезного сбоя, \autocite{PITRintro};
    \item Периодическое тестирование системы на предмет нарушения целостности, анализ логов БД, а также использование IDS с целью попыток выявления попыток несанкционированного изменения данных \autocite{DBtest}.
    \item Использование отказоустойчивых серверов, UPS (системы бесперебойного питания), аппаратных средств шифрования, осуществление контроля доступа к серверному оборудованию \autocite{tolerance1, tolerance2}.

\end{itemize}

\subsection{Метаданные и словарь данных}

\begin{grayquote}
	\textbf{Метаданные} -- Это данные, описывающие другие данные. Это важный элемент хранилища данных, который предоставляет возможность показывать пользователю предметно-ориентированную структуру, а не набор абстрактно-связанных таблиц. Метаданные предназначены для хранения информации о происхождении данных, о любых изменениях данных, о расположении данных, об ограничениях на данные, о соответствии данных тем или иным объектам предметной области и т. д. \autocite{Pirogov2009}
\end{grayquote}

Говоря более простым языком: 
Если \textbf{данные} — то, что хранится в базе данных приложения (данные о клиентах, пользователях, заказах и т.п.), то \textbf{метаданные} — это описание структуры данных. Описание того, какие типы объектов хранятся в базе данных, какие у них есть поля (атрибуты, элементы), описание зависимостей между объектами. В общем случает типы могут наследовать атрибуты родительского типа, а один атрибут в общем случае может присутствовать у двух и более типов, несвязанных отношением наследования \autocite{Metadatahabr}.

\subsubsection{Назначение словаря данных} ~\\

Согласно реляционной модели данных, информация о структуре базы данных должна храниться в самой базе данных, в виде специальных таблиц. Это требование описано в 4-м правиле Кодда (Dynamic On-Line Catalog Based on the Relational Model), согласно которому СУБД должна автоматически управлять метаданными и обеспечивать их доступность через стандартные средства запросов.

Для организации хранения метаданных в реляционных СУБД используются системные каталоги, которые также называют "словари данных".

\begin{grayquote}
    \textbf{Системный каталог} — это совокупность специальных таблиц, автоматически создаваемых и управляемых самой СУБД. Он содержит информацию о структуре базы данных, включая перечень таблиц, индексов, ограничений целостности, а также сведения о пользователях, их привилегиях и других параметрах системы \autocite{IntuitLec14}.
\end{grayquote}

Системные каталоги со временем развивались. Первые реализации каталогов появились еще в 1970-х годах в исследовательских проектах \textbf{IBM System R} и \textbf{Ingres}, но формально описание системного каталога было включено в стандарт \textbf{SQL-86}. В нем задавались базовые требования к хранению метаданных, но без единого формата их представления \autocite{DictHist}.

В \textbf{SQL-92} была стандартизирована структура системного каталога, а точнее представления, объединенные в схему \texttt{INFORMATION\_SCHEMA}. Эта штука в какой-то степени развязала руки разработчикам писать универсальные запросы для получения информации о таблицах, индексах, ограничениях и других объектах БД вне зависимости от конкретной СУБД. Однако на момент принятия стандарта, многие СУБД уже использовали собственные форматы каталогов, и их переход на \texttt{INFORMATION\_SCHEMA} оказался затруднительным.

\subsubsection{Реализация системных каталогов в разных СУБД}

Реализация и организация системных каталогов отличаются в зависимости от СУБД.

\begin{enumerate}
    \item \textbf{PostgreSQL}. \autocite{PostgreSQLdocc51,HabrDataOrgp1,YTcoursepostgre}
    
    В PostgreSQL системный каталог — это набор таблиц и представлений, содержащих метаданные обо всех объектах базы данных. Эти таблицы расположены в схеме \texttt{pg\_catalog}, которая по умолчанию включена в путь поиска. То есть можно обращаться к таблицам без явного указания схемы. Примеры таких таблиц: \texttt{pg\_class} (информация о таблицах и представлениях), \texttt{pg\_attribute} (сведения о столбцах) и \texttt{pg\_index} (данные об индексах). \autocite{PostgreSQLdocc51}

    Хотя системные каталоги и являются обычными таблицами, их прямое изменение не рекомендуется, так как это может привести к некорректной работе системы. Для внесения изменений рекомендуется использовать соответствующие SQL-команды, такие как \texttt{CREATE TABLE}, которая автоматически обновляет соответствующие записи в системном каталоге.

    Для получения информации из системного каталога рекомендуется использовать стандартные представления, наподобие \texttt{information\_schema}.

    Подробную информацию о системных каталогах PostgreSQL можно найти в официальной документации. \autocite{PostgreSQLdocc51}

    \item \textbf{MySQL}.
    
    В MySQL метаданные о базах данных и их объектах хранятся в специальной базе данных под названием \texttt{information\_schema}. Эта база данных содержит набор представлений, предоставляющих информацию о структурах баз данных (таблицах, столбцах, индексах, привилегиях пользователей).

    Например, представление \texttt{TABLES} в \texttt{information\_schema} содержит информацию обо всех таблицах, их имена, типы и используемые механизмы хранения. Представление \texttt{COLUMNS} дает сведения о столбцах таблиц (имена, типы данных и дополнительные характеристики).

    Доступ к данным в \texttt{information\_schema} осуществляется с помощью стандартных SQL-запросов. Например, получить список всех таблиц в определенной базе данных можно следующим запросом:

    \begin{lstlisting}[language=SQL]
    SELECT table_name
    FROM information_schema.tables
    WHERE table_schema = 'DATABASE_NAME';
    \end{lstlisting}

    Подробную информацию о структуре и содержимом \texttt{information\_schema} можно найти в официальной документации MySQL. \autocite{Mysqldoc1}
    
    Также стоит отметить, что в MySQL физическое хранение данных организовано в виде файловой системы, где каждая база данных представлена как подкаталог в основном каталоге данных сервера. Внутри каждого подкаталога файлы соответствуют таблицам и другим объектам базы данных. \autocite{IntuitMySQLadm}

    \item \textbf{Microsoft SQL Server}. \autocite{MicrosoftLearnSQLserver,professorweb,HabrTsql}

    В Microsoft SQL Server метаданные обо всех объектах базы данных хранятся в системных представлениях каталога, расположенных в схеме \texttt{sys}. Информация этих представлений содержит данные о таблицах, представлениях, столбцах, индексах, ограничениях и прочих объектах БД. Использование системных представлений позволяет администраторам и разработчикам получать структурированную информацию о состоянии БД и её объектах.
    
    \subparagraph{Основные представления каталога} ~\\
    
    Примеры наиболее часто используемых представлений:
    
    \begin{itemize}
        \item \texttt{sys.tables} — информация о всех таблицах в БД (имена, идентификаторы, даты создания);
        \item \texttt{sys.columns} — сведения о столбцах таблиц (имена, типы данных, порядковые номера);
        \item \texttt{sys.indexes} — информация об индексах (типы индексов, их назначение);
        \item \texttt{sys.foreign\_keys} — сведения о внешних ключах (ограничения ссылочной целостности);
        \item \texttt{sys.database\_principals} — информация о пользователях БД.
    \end{itemize}
    
    \subparagraph{Примеры запросов к системным представлениям} ~\\
    
    Для получения списка всех таблиц в текущей БД используется SQL-запрос:
    
    \begin{lstlisting}[language=SQL]
    SELECT name 
    FROM sys.tables;
    \end{lstlisting}
    
    Если необходимо получить список всех столбцов конкретной таблицы:
    
    \begin{lstlisting}[language=SQL]
    SELECT column_name, data_type, is_nullable
    FROM information_schema.columns
    WHERE table_name = 'Employees';
    \end{lstlisting}
    
    Для просмотра индексов таблицы:
    
    \begin{lstlisting}[language=SQL]
    SELECT i.name AS IndexName, t.name AS TableName
    FROM sys.indexes i
    JOIN sys.tables t ON i.object_id = t.object_id
    WHERE t.name = 'Employees';
    \end{lstlisting}
    
    \subparagraph{Рекомендации по использованию} ~\\
    
    Рекомендуется использовать системные представления каталога вместо прямого доступа к системным таблицам, так как представления:
    
    \begin{itemize}
        \item предоставляют стандартизированный интерфейс для получения метаданных;
        \item обеспечивают обратную совместимость при обновлении версий SQL Server;
        \item позволяют получать данные в удобном формате без необходимости разбираться во внутренней структуре системы.
    \end{itemize}

    \item \textbf{Oracle}.

    В Oracle Database словарь данных состоит из нескольких наборов представлений. Во многих случаях такой набор состоит из трех представлений, содержащих аналогичную информацию и отличающихся друг от друга своими префиксами \autocite{Kirillov2009}.\\

    Словарь данных базы данных Oracle имеет два основных применения:
    \begin{itemize}
        \item Oracle обращается к словарю данных каждый раз, когда выполняются команды языка DDL (Data Definition Language), например \texttt{CREATE TABLE}, \texttt{ALTER TABLE}, \texttt{DROP TABLE} и тд. Например, при создании таблицы Oracle вносить соответвсуюшую запись в \texttt{DBA\_TABLES} и \texttt{ALL\_TABLES}.
        \item каждый пользователь Oracle может обращаться к словарю данных как к справочнику со сведениями по базе данных (доступные объекты). Нпример DBA может юзать словарь данныхх для мониторинга структуры схемы или например анализа привилегий юзеров
    \end{itemize}

    При этом словарь данных всегда доступен при открытой базе данных. Он размещается в табличном пространстве SYSTEM, которое всегда находится в состоянии Online, когда база данных открыта.

    Основные категории представлений \autocite{oracledbdoc1}:
    \begin{enumerate}

        \item \textbf{Представления с префиксом \texttt{USER\_}} содержат информацию об объектах, принадлежащих текущему пользователю. Напирмер \texttt{USER\_TABLES} отображает таблицы, созданные текущим пользователем, а \texttt{USER\_TAB\_COLUMNS} даст инфу о столбцах тааблиц пользователя.
        Пример запроса:
        \begin{lstlisting}[language=SQL]
        SELECT table_name 
        FROM user_tables;
        \end{lstlisting}

        \item \textbf{Представления с префиксом \texttt{ALL\_}} предоставляют информацию обо всех объектах, к которым текущий пользователь имеет доступ, независимо от владельца. Например \texttt{ALL\_TABLES} показывает все таблицы, доступные пользователю. \texttt{ALL\_TAB\_COLUMNS} показывает информацию о столбцах всех доступнх таблиц.
        Пример запроса:
        \begin{lstlisting}[language=SQL]
        SELECT table_name 
        FROM all_tables 
        WHERE owner = 'HR';
        \end{lstlisting}

        \item \textbf{Представления с префиксом \texttt{DBA\_}} содержат информацию обо всех объектах в БД и доступны только пользователям с соответствующими привилегиями (типа админ). К примеру \texttt{DBA\_TABLES} предоставляет список всех таблиц в БД, \texttt{DBA\_USERS} - информациб обо всех пользователях БД.
        Пример запроса:
        \begin{lstlisting}[language=SQL]
        SELECT username 
        FROM dba_users;
        \end{lstlisting}

    \end{enumerate}

    Столбцы в представленях с префиксами \texttt{USER\_}, \texttt{ALL\_}, \texttt{DBA\_} идентичны, но есть нюанс. Объем данных возвращаемых каждый представлением зависит от прав доступа пользователя. В представлениях \texttt{USER\_} к примеру обычно нет столбца \texttt{OWNER}, так как подразумевается что владелец это текущий пользователь, выдавший запрос. Некоторые представления DBA имеют дополнительные столбцы, которые содержат информацию, полезную для БД.

    \textbf{Динамические представления происзводительности \texttt{V\textdollar}}. \autocite{oracledbdoc2}

    Помимо статических представлений словаря данных, Oracle предоставляет Dynamic Performance Views, также извесные как \texttt{V\textdollar}-представления. Они содержат информацию о текущем состоянии БД и её производительности. Они обновляются в реальном времени и позволяют отслеживать активность системы, типа там текущие сессии, параметры, статистику производительности и тд. То есть используются они для мониторинга активности БД в рельном времени.

    Как пример можно привести \texttt{V\textdollar SESSION} (информация о текущих подключенных сессиях) или \texttt{V\textdollar PARAMETER} (текущие параметры конфигурации БД).

    Пример запроса:
    \begin{lstlisting}[language=SQL]
    SELECT sid, serial#, username, status 
    FROM v$session 
    WHERE status = 'ACTIVE';
    \end{lstlisting}
    
\end{enumerate}

\subsubsection{Логическая структура словаря данных} ~\\

Логическая структура словаря данных \autocite{PostgreSQLdocc51,ElmasriNavathe,Silberschatz} включает в себя:

\begin{enumerate}
    \item Описание структуры объектов базы данных (информация о таблицах, индексах, ограничениях, связях между объектами БД)
    \item Метаданные о транзакциях (сведения о выполняемых операциях, механизах блокировок, истории SQL-запросов)
    \item Статистику работы системы (данные о производительности, статистике выполнения запросов, параметрах конфигурации СУБД)
\end{enumerate}

Далее последовательно будут рассмотрены каждый из этих пунктов

Также важно надо понимать разницу между \textbf{логической} и \textbf{физической} структурой словаря данных:

\begin{itemize}
    \item \textbf{Логическая структура} описывает, какие именно данные хранятся, в каком виде они представлены, как взоимосвязаны между собой.
    \item \textbf{Физическая структура} (рассмотрится далее) описывает где и как хранятся данные словаря, какие файлы и таблицы используются.
\end{itemize}

Словари данных могут быть \textbf{стандартные} и \textbf{вендор-зависимые}:

\begin{enumerate}
 
    \item Стандартные словари данных реализованы по международным стандартам SQL и обеспечивают SQL-запросы к словарю совместимыми между различными СУБД. Ключевой пример – схема \texttt{INFORMATION\_SCHEMA} (введенная в стандарт SQL-92). Оно поддерживается в MySQL, Microsoft SQL Server, PostgreSQL и других СУБД и позволяет разработать межплатформенные решения.

        \textbf{Пример SQL-запроса}:
        \begin{lstlisting}[language=SQL]
        SELECT table_name, column_name, data_type 
        FROM INFORMATION_SCHEMA.COLUMNS 
        WHERE table_schema = 'public';
        \end{lstlisting}

    \item Вендор-зависимые словари данных реализованы специфическими разработчиками СУБД и как правило зачастую \textbf{предоставляют расширенные возможности, недоступные в стандартных словарях}. 

    Примеры вендор-зависимых системных каталогов:
    \begin{itemize}
        \item PostgreSQL: \texttt{pg\_catalog} – содержит таблицы \texttt{pg\_tables}, \texttt{pg\_indexes}, \texttt{pg\_roles} (расширеные метаданные о структуре БД).
        \item Microsoft SQL Server: \texttt{sys.*} – набор системных представлений, включающий \texttt{sys.tables}, \texttt{sys.columns}, \texttt{sys.indexes} и другие.
        \item Oracle: \texttt{DBA\_*}, \texttt{ALL\_*}, \texttt{USER\_*} – системные представления для админов, юзеров и всех объектов бд.
    \end{itemize}

\end{enumerate}

\begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|}
        \hline
        \textbf{Тип словаря} & \textbf{Пример в СУБД} & \textbf{Совместимость} \\
        \hline
        Стандартный & INFORMATION\_SCHEMA & Высокая (MySQL, SQL Server, PostgreSQL) \\
        \hline
        Вендор-зависимый & pg\_catalog (PostgreSQL) & Ограниченная (только PostgreSQL) \\
        \hline
        Вендор-зависимый & sys.* (SQL Server) & Только Microsoft SQL Server \\
        \hline
        Вендор-зависимый & DBA\_* (Oracle) & Только Oracle DB \\
        \hline
    \end{tabular}
    \caption{Стандартные и вендор-зависимые словари данных}
    \label{tab:data_dictionary_comparison}
\end{table}

Таким образом, использование вендор-зависимых требует всяких специфических знаний конкретной платформы.

Итак, перейдем к рассмотрению указанных ранее пунктов:

\paragraph{Основные объекты, хранящиеся в словаре данных} ~\\

\begin{enumerate}

    \item Таблицы и их атрибуты \autocites[§51.11]{PostgreSQLdocc51}[§28.3.38]{Mysqldoc1}{MicrosoftLearnSQLserver}

    Одним из основных компонентов словаря данных является информация о таблицах и их атрибутах. В реляционной модели данные организованы в виде таблиц, и их структура должна быть четко определена и документирована.

    \begin{enumerate}
        \item Метаданные о таблицах

        \begin{itemize}
            \item Название таблицы (\texttt{table\_name}).
            \item Схема (пространство имен) (\texttt{schema\_name}).
            \item Тип таблицы (обычная, временная, внешняя и т. д.).
            \item Дата создания и последнего изменения.
            \item Физическое расположение таблицы (табличное пространство, файловая группа).
            \item Владелец таблицы (создатель).
            \item Размер таблицы (количество строк, объем занимаемого пространства на диске).
        \end{itemize}

        Пример SQL-запроса (PostgreSQL, получение информации о таблицах):
        \begin{lstlisting}[language=SQL]
        SELECT schemaname, tablename, tableowner, tablespace 
        FROM pg_tables;
        \end{lstlisting}

        Примеры расположения метаданных о таблицах в разных СУБД:
        \begin{itemize}
            \item PostgreSQL: \texttt{pg\_class}, \texttt{pg\_tables}.
            \item MySQL: \texttt{INFORMATION\_SCHEMA.TABLES}.
            \item SQL Server: \texttt{sys.tables}.
            \item Oracle: \texttt{ALL\_TABLES}, \texttt{USER\_TABLES}, \texttt{DBA\_TABLES}.
        \end{itemize}

        \item Атрибуты (столбцы) таблиц
    
        Кроме информации о таблице в целом, важно хранить сведения о ее столбцах и их свойствах:
        
        \begin{itemize}
            \item Имя столбца (\texttt{column\_name}).
            \item Тип данных (\texttt{VARCHAR}, \texttt{INTEGER}, \texttt{BOOLEAN} и т. д.).
            \item Размерность данных (\texttt{length}, \texttt{precision}, \texttt{scale}).
            \item Значение по умолчанию.
            \item Является ли столбец автоинкрементным (\texttt{SERIAL}, \texttt{IDENTITY} и т. д.).
            \item Описание (комментарий к столбцу, если поддерживается СУБД).
        \end{itemize}

        Пример SQL-запроса (MySQL, получение информации о столбцах таблицы):
        \begin{lstlisting}[language=SQL]
        SELECT COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, IS_NULLABLE 
        FROM INFORMATION_SCHEMA.COLUMNS 
        WHERE TABLE_NAME = 'employees';
        \end{lstlisting}
    \end{enumerate}
    
    \item Индексы \autocites[§51.26]{PostgreSQLdocc51}[§52.11]{PostgreSQLdocc52}[§28.3.34]{Mysqldoc1}{MicrosoftLearnSQLserverInd}

    Индексы важны в плане повышения производительности запросов. Они позволяют ускорить поиск данных, но увеличевают объем занимаемого дискового пространства.

    В словаре данных хранятся метаданные о индексах:
    \begin{itemize}
        \item Название индекса.
        \item Тип индекса (\texttt{B-Tree}, \texttt{Hash}, \texttt{GIN}, \texttt{Full-text}).
        \item Таблица, к которой индекс относиться.
        \item Столбцы, использованные для индексации.
        \item Параметры индекса (уникальность, сортировка, частичность).
        \item Статистика использования индекса (сколько раз использовался, степень фрагментации).
    \end{itemize}

    Примеры росположения индексов в разных СУБД:
    \begin{itemize}
        \item PostgreSQL: \texttt{pg\_index}, \texttt{pg\_class}, \texttt{pg\_indexes}.
        \item MySQL: \texttt{INFORMATION\_SCHEMA.STATISTICS}.
        \item SQL Server: \texttt{sys.indexes}, \texttt{sys.index\_columns}.
        \item Oracle: \texttt{DBA\_INDEXES}, \texttt{USER\_INDEXES}.
    \end{itemize}

    Пример SQL-запроса (Oracle, получение информации об индексах таблицы):
    \begin{lstlisting}[language=SQL]
    SELECT INDEX_NAME, TABLE_NAME, UNIQUENESS, STATUS 
    FROM DBA_INDEXES 
    WHERE TABLE_NAME = 'EMPLOYEES';
    \end{lstlisting}

    \item Ограничения целостности \autocites[§51.13]{PostgreSQLdocc51}[§28.3.42]{Mysqldoc1}{MicrosoftLearnSQLserverTab}

    Они служат для обиспечения корректности данных в таблицах

    Хранимая информация:
    \begin{itemize}
        \item Тип ограничения (\texttt{PRIMARY KEY} (определяет основной ключ таблицы), \texttt{FOREIGN KEY} (обеспечивает ссылочную целостность), \texttt{CHECK} (накладывает ограничения на значения столбцов), \texttt{UNIQUE} (гарантирует уникальность значений в таблице), \texttt{NOT NULL} (запрет хранить NULL в столбце))
        \item Целевая таблица (на которую наклыдвается ограничение целостности) и столбцы.
        \item Дейстия при удалени илии обновлении (\texttt{ON DELETE CASCADE}, \texttt{ON UPDATE SET NULL}).
    \end{itemize}

    Примеры раcположения метаданных об ограничениях в разных СУБД:
    \begin{itemize}
        \item PostgreSQL: \texttt{pg\_constraint}
        \item MySQL: \texttt{INFORMATION\_SCHEMA.KEY\_COLUMN\_USAGE}, \texttt{INFORMATION\_SCHEMA.TABLE\_CONSTRAINTS}
        \item SQLServer: \texttt{sys.foreign\_keys}, \texttt{sys.check\_constraints}, \texttt{sys.key\_constraints}
        \item Oracle: \texttt{ALL\_CONSTRAINTS}, \texttt{USER\_CONSTRAINTS}, \texttt{DBA\_CONSTRAINTS}
    \end{itemize}

    Пример SQL-запроса (PostgreSQL, получение ограничений таблицы):
    \begin{lstlisting}[language=SQL]
    SELECT conname, contype, conrelid::regclass AS table_name 
    FROM pg_constraint 
    WHERE conrelid = 'employees'::regclass; 
    \end{lstlisting}

    Пример SQL-запроса (MySQL, ограничение \texttt{UNIQUE} на \texttt{email} в таблице \texttt{users}):
    \begin{lstlisting}[language=SQL]
    ALTER TABLE users
    ADD CONSTRAINT unique_email UNIQUE (email);    
    \end{lstlisting}

    Пример SQL-запроса (PostgreSQL, ограничение \texttt{FOREIGN KEY} для \texttt{orders.customer\_id}, ссылающееся на \texttt{customers.id}):
    \begin{lstlisting}[language=SQL]
    ALTER TABLE orders
    ADD CONSTRAINT fk_customer FOREIGN KEY (customer_id)
    REFERENCES customers(id) ON DELETE CASCADE;
    \end{lstlisting}

    \item Пользователи и их права \autocite{MicrosoftLearnSQLserverPerm, oracledbdoc3}

    Для управления доступов к БД в словаре данных хранится информация о пользователях, их привилегиях и ролях:
    \begin{itemize}
        \item Список всех пользователей СУБД (\texttt{user\_name} пользователей).
        \item Назначенные роли (\texttt{DBA}, \texttt{PUBLIC}, \texttt{SUPERUSER}).
        \item Гранты привилегий на обьекты (\texttt{SELECT}, \texttt{INSERT}, \texttt{UPDATE}, \texttt{DELETE}).
    \end{itemize}

		Примеры расположения метаданных о пользователях в разных СУБД:

    \begin{itemize}
        \item PostgreSQL: \texttt{pg\_roles}, \texttt{pg\_authid}.
        \item MySQL: \texttt{mysql.user}, \texttt{INFORMATION\_SCHEMA.USER\_PRIVILEGES}.
        \item SQLServer: \texttt{sys.database\_principals}, \texttt{sys.database\_role\_members}.
        \item Oracle: \texttt{DBA\_USERS}, \texttt{ALL\_USERS}, \texttt{USER\_USERS}.
    \end{itemize}

    Пример SQL-запроса (PostgreSQL):
    \begin{lstlisting}[language=SQL]
    SELECT rolname, rolsuper, rolcreatedb, rolcanlogin 
    FROM pg_roles;             
    \end{lstlisting}

    Пример SQL-запроса (SQL Server, получение списка пользователей и их ролей):
    \begin{lstlisting}[language=SQL]
    SELECT name, type_desc 
    FROM sys.database_principals 
    WHERE type IN ('S', 'U');              
    \end{lstlisting}

\end{enumerate}

\paragraph{Метаданные о транзакциях} ~\\

\begin{grayquote}
    \textbf{Транзакция} - это исполняемая программа, включающая в себя определенные операции с базой данных, такие как чтение из базы данных, применение вставок, удалений или обновлений к базе данных \autocite{ElmasriNavathe}.
\end{grayquote}

Основной смысл транзакций заключается в в объединении нескольких операций в одно неделимое действие. Промежуточные состояния между шагами транзакции невидимы для других параллельно выполняющихся транзакций. Если происходит сбой, не позволяющий транзакции завершиться, то никакие изменения базу данных не затрагивают — все шаги откатываются. \autocite{PostgreSQLdocc3p4}

Соответственно, \textbf{метаданные о транзакциях} — это информация, фиксируемая СУБД в процессе выполнения транзакций. Они позволяют отслеживать историю изменений, анализировать работу БД и обеспечивать контроль целостности данных. В словаре данных хранятся в виде специальных системных таблиц и представлений, содержащих информацию о выполняемых операциях, механизмах блокировок, истории SQL-запросов.

\subparagraph{Журнылы операций} ~\\

\textbf{Журналы операций} фиксируют информацию о транзакциях выполняемых в СУБД чтобы их можно было восстановить в случае сбоя (сделать \texttt{ROLLBACK}). Они являются основным источником информации о транзакциях в СУБД. Они фиксируют:
\begin{itemize}
    \item Время начала и завершения транзакции.
    \item ID транзакции.
    \item Тип выполняемой операции (INSERT, UPDATE, DELETE, DDL-операции).
    \item Пользователя, выполнявшего операцию.
    \item Затронутые (повергнувшиеся изменению) таблицы и строки.
    \item Использованные механизмы блокировок.
\end{itemize}

Используются они как уже было сказано для отката изменений (\texttt{ROLLBACK}).
Вот как это реализовано в различных СУБД:

\begin{itemize}
    \item PostgreSQL: Журналы транзаций хранятся в WAL (Write-Ahead Logging), а информация о транзакциях пишется в \texttt{pg\_xact} и \texttt{pg\_commit\_ts} \autocite{PostgreSQLdocc28}.
    \item MySQL использует бинарные логи (Binary Log, binlog), фиксирующие события для репликации и востановления. \autocite{Mysqldoc3}. Также есть штука \texttt{performance\_schema.events\_transactions}, которая фиксирует события связанные с выполнением транзакций и хранящяя подробную информацию о них (ID, состояния, временные метки начала и конца, статистику) \autocite{Mysqldoc2}. То есть binlog фиксирует изменения данных для цели репликации, восстановления, а эта штука используется для мониторинга работы транзакций в реальном времени, но не предназначена для восстановления данных. 
    \item SQL Server: журнал транзакций (Transaction Log), \texttt{sys.dm\_tran\_active\_transactions} \autocite{MicrosoftLearnSQLserverTransLog}.
    \item Oracle: журналы восстановления (Redo Logs), \texttt{V\textdollar TRANSACTION}, \texttt{V\textdollar LOG} \autocite{OracleRedoLog}.
\end{itemize}

Пример запроса (PostgreSQL, просмотр текущего состояния WAL-журнала. Как итог получаем текущий LSN (Log Sequence Number) в WAL-журнале. LSN указывает до какого момента были записаны изменения в журнале транзакций):
\begin{lstlisting}[language=SQL]
    SELECT * FROM pg_current_wal_lsn();                
\end{lstlisting}

Пример запроса (MySQL, просмотр 10 последних записанных в журнал транзакций событий, записанных в binlog):
\begin{lstlisting}[language=SQL]
    SHOW BINLOG EVENTS IN 'mysql-bin.000001' LIMIT 10;           
\end{lstlisting}

\subparagraph{История выполнения SQL-запросов} ~\\

Также многие СУБД ведут \textbf{историю выполненных SQL-запросов}. Она используется для анализа работы системы, поиска узких мест в производительности, аудит безопасности. 

Реализация следующяя:
\begin{itemize}
    \item PostgreSQL: история запросов хранится в \texttt{pg\_stat\_statements} \autocite{PgStatStatements1}
    \item MySQL: используются \texttt{general\_log} и \texttt{slow\_query\_log} \autocite{Mysqldoc3}
    \item SQL Server: представление \texttt{sys.dm\_exec\_query\_stats} \autocite{MicrosoftLearnSQLserverQueryStat}
    \item Oracle: динамические представления \texttt{V\textdollar SQL}, \texttt{V\textdollar SQLAREA} \autocite[c.9 §46-49, c.9 §71]{oracledbdoc2}
\end{itemize}

Пример запроса (PostgreSQL, выводит 5 самых долгих рисурсоемких запросов):
\begin{lstlisting}[language=SQL]
    SELECT query, calls, total_exec_time 
    FROM pg_stat_statements 
    ORDER BY total_exec_time DESC 
    LIMIT 5;                 
\end{lstlisting}

Пример запроса (Oracle, \texttt{V\textdollar SQLAREA}, выборка последних запросов с частотой их выполнения и затратами ресурсов (10 штук запросов)):
\begin{lstlisting}[language=SQL]
    SELECT sql_text, executions, 
        elapsed_time / executions AS avg_exec_time, 
        disk_reads, buffer_gets 
    FROM V$SQLAREA 
    WHERE executions > 0 
    ORDER BY first_load_time DESC 
    FETCH FIRST 10 ROWS ONLY;
\end{lstlisting}

\subparagraph{Информация о блокировакх и параллельном доступе} ~\\

Многопользоательский доступ требует механизмов блокировок для отсутствия ситуации, когда происходит одновременная модификация одних и тех же данных разными транзакциями. В словаре данных фиксируется информация о:
\begin{itemize}
    \item Активных блокировках (\texttt{SHARE}, \texttt{EXCLUSIVE}).
    \item Процессах, ожидающих снятия блокировок.
    \item Возникших взаимоблокировках (deadlocks).
    \item Длительности удержания блокировки.
    \item Таблицах и строках, находящихся в блокировке.
\end{itemize}

На практике реализовано следующим образом:
\begin{itemize}
    \item PostgreSQL: Информация о блокировках содержится в \texttt{pg\_locks} и \texttt{pg\_stat\_activity} \autocites[§52.12]{PostgreSQLdocc52}[§27.2.3]{PostgreSQLdocc27}.
    \item MySQL: \texttt{performance\_schema.metadata\_locks} \autocite[§29.12.13]{Mysqldoc2}.
    \item SQL Server: используется представление \texttt{sys.dm\_tran\_locks} \autocite{MicrosoftLearnSQLserverTranLocks}.
    \item Oracle: блокировки отслеживаются \texttt{V\textdollar LOCK}, \texttt{DBA\_BLOCKERS}, \texttt{DBA\_WAITERS} \autocites[c.8 §40]{oracledbdoc2}[c.4 §180, c.6 §103]{oracledbdoc1}.
\end{itemize}

Пример запроса (PostgreSQL, поиск процессов ожидающих блокировки):
\begin{lstlisting}[language=SQL]
    SELECT pid, relation::regclass AS locked_table, mode, granted
    FROM pg_locks
    WHERE NOT granted;              
\end{lstlisting}

Пример запроса (SQL Server, поиск взаимоблокировок):
\begin{lstlisting}[language=SQL]
    SELECT blocking_session_id AS blocker, session_id AS blocked
    FROM sys.dm_exec_requests
    WHERE blocking_session_id IS NOT NULL;             
\end{lstlisting}

Согласно требованиям ACID (Atomic, Consistent, Isolated, Durable) транзакция должна быть устойчивой. После своего завершения она сохраняется в системе, которую ничто не может вернуть в исходное (до начала транзакции) состояние, т. е. происходит фиксация транзакции (\texttt{COMMIT}), означающая, что ее действие постоянно даже при сбое системы. При выполнении отдельных операций транзакции могут быть нарушены какие-либо требования целостности данных (в первую очередь имеются в виду корпоративные правила целостности, см. главу 2). Однако по окончании выполнения транзакции (фиксация транзакции) все правила целостности базы данных будут соблюдены.

В большинстве реляционных СУБД фиксация сначала записывает изменения в журнал транзакций (например, WAL или Binary Log), а затем применяет их к основным данным. Это позволяет минимизировать потери в случае сбоя и поддерживать \texttt{ROLLBACK}, если транзакция не была завершена.

Транзакция начинается с первой команды, которая обращается к данным, и продолжается до тех пор, пока не будет явного завершения с помощью \texttt{COMMIT WORK} (или просто \texttt{COMMIT}) либо не будет закрыто соединение к базе данных. Ткаже возможно явное открытие транзакии с помощью \texttt{BEGIN TRANSACTION} (\texttt{START TRANSACTION} в MySQL). При выполнении \texttt{COMMIT} происходит фиксация транзакции, и \texttt{ROLLBACK} уже будет невозможен \autocite{Pirogov2009}. Однако поведение на самом деле зависит от СУБД.

Например, в PostgreSQL и MySQL разрыв соединения без \texttt{COMMIT} приводит к автоматическому \texttt{ROLLBACK}, а в SQL Server и Oracle возможны различные настройки (по умолчанию транзакция фиксируется при разрыве соединение но можно включить поведение с откатом).

Пример явного управления транзакцией в PostgreSQL (демонстрация атомарности транзакции при переводе средств между мнимымии счетами):
\begin{lstlisting}[language=SQL]
    BEGIN;
    UPDATE accounts SET balance = balance - 100 WHERE id = 1;
    UPDATE accounts SET balance = balance + 100 WHERE id = 2;
    COMMIT;           
\end{lstlisting}


\paragraph{Статистика работы СУБД} ~\\

Статистика работы СУБД также представляет из себя метаданные которые фиксируют информацию о произчодительности системы, нагрузке на сервер, использовании индексов, частоте выполнения запросов. Подобного рода данные дают возможность админам анализировать производительность БД и оптимизировать систему.

\subparagraph{Анализ производительности} ~\\

Анализ производительности позволяет определить, какие запросы и операции замедляют работу СУБД. Для этого мониторится:
\begin{itemize}
    \item Использование процессора (время выполнения SQL-запросов, нагрузка на CPU)
    \item Операции чтения/записи на диск и использование кэша
    \item Потребление памяти (размер буферного кэша, использование индексов)
\end{itemize}

В разных СУБД следующие механизмы для анализа производительности:
\begin{itemize}
    \item PostgreSQL: \texttt{pg\_stat\_statements}, \texttt{pg\_stat\_activity}, \texttt{pg\_stat\_bgwriter} \autocite[§27.2]{PostgreSQLdocc27}
    \item MySQL: \texttt{performance\_schema}, \texttt{INFORMATION\_SCHEMA.PROCESSLIST} \autocite{Mysqldoc2}
    \item SQL Server: \texttt{sys.dm\_exec\_requests}, \texttt{sys.dm\_exec\_query\_stats} \autocite{MicrosoftLearnSQLserverSysDymView}
    \item Oracle: \texttt{V\textdollar SYSSTAT}, \texttt{V\textdollar SESSION}, \texttt{V\textdollar SQL} \autocite[c. 9 §9.98, §9.17, §9.46]{oracledbdoc2}
\end{itemize}

Пример PostgreSQL — анализ нагрузки активных запросов. Определяет SQL-запросы с наибольшим временем выполнения:
\begin{lstlisting}[language=SQL]
    SELECT pid, query, calls, total_exec_time / calls AS avg_exec_time
    FROM pg_stat_statements
    ORDER BY avg_exec_time DESC
    LIMIT 5;        
\end{lstlisting}

Другой пример (MySQL, анализ медленных запросов)
\begin{lstlisting}[language=SQL]
    SELECT start_time, user_host, query_time, sql_text
    FROM mysql.slow_log
    ORDER BY query_time DESC
    LIMIT 5;        
\end{lstlisting}

\subparagraph{Статистика выполнения запросов} ~\\

Статистические данные также использутся для оптимизации индексов (анализируется частота обращения к различным таблицам), выявления "дорогих" запросов (запросов с высокой нагрузкой на процессор или диск) и настройки кэша и оценки эффективности буферизации данных.

Примеры механизмов сбора статистики запросов:
\begin{itemize}
    \item PostgreSQL: \texttt{pg\_stat\_statements} хранит частоту и среднее время выполнения запросов
    \item MySQL: \texttt{performance\_schema.events\_statements\_summary\_by\_digest} агрегирует запросы по шаблону
    \item SQL Server: \texttt{sys.dm\_exec\_query\_stats} дает инфорамцию о частоте выполнения запросов
    \item Oracle: \texttt{V\textdollar SQLAREA} хранит статистику о выполненных запросах
\end{itemize}

Пример (SQL Server, анализ самых ресурсозатратных запросов)
\begin{lstlisting}[language=SQL]
    SELECT TOP 5 
        total_logical_reads AS Reads, 
        total_worker_time AS CPU_Time, 
        execution_count AS Executions, 
        text AS Query_Text 
    FROM sys.dm_exec_query_stats qs
    CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle)
    ORDER BY total_worker_time DESC;
\end{lstlisting}

Пример (Oracle, последние 10 выполненных запросов, показывает частоту и среднее время выполнения)
\begin{lstlisting}[language=SQL]
    SELECT sql_text, executions, elapsed_time / executions AS avg_exec_time
    FROM V$SQLAREA
    WHERE executions > 0
    ORDER BY first_load_time DESC
    FETCH FIRST 10 ROWS ONLY;
\end{lstlisting}

\subparagraph{Автоматическая сборка аналитики СУБД} ~\\

Некоторые (все из рассматриваемых четырех) СУБД автоматически анализируют статистику и используют её для внутренней оптимизации
\begin{itemize}
    \item PostgreSQL: \texttt{pg\_stat\_statements} автоматически анализирует запросы и создает план выполнения.
    \item MySQL: \texttt{performance\_schema.setup\_instruments} мониторит работу серверных процессов.
    \item SQL Server: \texttt{Query Store} хранит статистку выполнения запросов и их планы.
    \item Oracle: \texttt{V\textdollar SQL\_PLAN}, \texttt{V\textdollar SQL\_OPTIMIZER\_ENV} отслеживают параметры оптимизатора.
\end{itemize}

Пример (PostgreSQL, анализ частоты выполнения запросов)
\begin{lstlisting}[language=SQL]
    SELECT query, calls, total_exec_time / calls AS avg_exec_time
    FROM pg_stat_statements
    ORDER BY calls DESC
    LIMIT 10;
\end{lstlisting}

Пример (Oracle, анализ плана выполнения запроса)
\begin{lstlisting}[language=SQL]
    SELECT sql_id, plan_hash_value, executions, buffer_gets, elapsed_time
    FROM V$SQL_PLAN
    ORDER BY elapsed_time DESC
    FETCH FIRST 5 ROWS ONLY;
\end{lstlisting}

\subsubsection{Физическая структура словаря данных} ~\\

Здесь будет обсуждено хранение метаданных внутри файловой системы рассматриваемых СУБД. В отличие от логической структуры, которая описывает структуру и взаимосвязь данных на уровне схем и объектов БД, физическая структура это расположение системных файлов, их формат и механизмы работы с пространством на диске.

\paragraph{Расположение метаданных в файловой системе} ~\\

\subparagraph{PostgreSQL} \autocite{PostgreSQLdocc65} ~\\

PostgreSQL хранит метаданные о БД в системных таблицах, но сами файлы с данными располагаются в каталоге PGDATA, обычно \texttt{/var/lib/postgresql/<version>/main/} (в Linux) или \texttt{C:\textbackslash{}Program Files\textbackslash{}PostgreSQL\textbackslash{}<version>\textbackslash{}data\textbackslash{}} (в Windows)
Также основные файлы и каталоги, связаные с метаданными:
\begin{itemize}
    \item \texttt{pg\_catalog/} содержит системные таблицы с метаданными (\texttt{pg\_class}, \texttt{pg\_attribute}, \texttt{pg\_roles} и т.д.).
    \item \texttt{pg\_xact} фиксирует состояние транзакций.
    \item \texttt{pg\_wal} - журнал предзаписи (WAL) для восстановления.
    \item \texttt{base/} - директория с данными всех баз (каждая база имеет свой подкаталок).
\end{itemize}

\subparagraph{MySQL} \autocite[§17.6]{Mysqldoc4} ~\\

Используются два формата хранения метаданных: файловый и табличный.

\begin{itemize}
    \item \texttt{datadir/} - каталог, где хранятся базы данных (обычно \texttt{var/lib/mysql}).
    \item \texttt{ibdata1} - общий файл хрвнилища InnoDB, там записаны метаданные.
    \item \texttt{ib\_logfile0}, \texttt{ib\_logfile1} - файлы журнала транзакций InnoDB.
    \item \texttt{.frm} - файлы схем таблиц (используютcя в MyISAM).
    \item \texttt{.ibd} - файлы хранения данных и индексов для InnoDB. 
\end{itemize}

\subparagraph{SQL Server} \autocite{MicrosoftLearnSQLserverMasterdb,MicrosoftLearnSQLserverTempdb,MicrosoftLearnSQLserverDBfiles,MicrosoftLearnSQLserverFileLoc} ~\\

Тут метаданные хранятся в системной базе даных \texttt{master}, а физически - в файлах формата MDF (основные файлы БД) и LDF (журналы транзакций)

\begin{itemize}
    \item \texttt{\%ProgramFiles\%\textbackslash{}Microsoft SQL Server\textbackslash{}MSSQL<number>.MSSQLSERVER\textbackslash{}MSSQL\textbackslash{}DATA\textbackslash{}} - каталог с данными.
    \item \texttt{master.mdf} - основной файл БД с метаданными о сервере, содержит важные метаданные (инфу о всех базах, пользователях, настройках).
    \item \texttt{tempdb.mdf} - временное хранилище данных, временная база данных, для операций а-ля с сортировками и индексами.
\end{itemize}


\subparagraph{Oracle} \autocites[§1.338]{oracledbdoc0}{oracledbdoc4}{OracleRedoLog} ~\\

В Oracle для хранения метаданных используются табличные пространства (\texttt{tablespaces}) и бинарные файлы:

\begin{itemize}
    \item \texttt{SYSTEM tablespace} - файл данных содержащий основные метаданные и системный каталог базы данных.
    \item \texttt{SYSAUX tablespace} - вспомогательный табличный каталог-хранилище метаданных.
    \item \texttt{REDO*.log} - файлы журналов транзакций.
    \item \texttt{spfile.ora} - бинарный файл параметорв базы данных.
    \item \texttt{V\textdollar DATAFILE}, \texttt{DBA\_TABLES} - таблицы системного словаря.
\end{itemize}

\subsection{Блокировки и параллельный доступ}

Этот раздел посвещен механизмам блокировок в СУБД \autocites[c.22]{ElmasriNavathe}[c. 18]{Silberschatz}. Параллельный (конкурентный) доступ к одной и той же информции приводит к проблемам целостности данных, если не использовать механизмы блокировок и управления транзакциями.

Основные вопросы, рассматривающиеся в этой части:
\begin{itemize}
		\item Почему вообще возникает проблема конкурентного доступа и какие ошибки могут произойти?
		\item Какие виды блокировок существуют, и как помогают избежать конфликтов?
    \item Как разные СУБД реализуют управление блокировками?
    \item Какие вообще существуют стратегии решения конфликтов при параллельном доустпе?
\end{itemize}

\subsubsection{Проблема параллельного доступа}

Нынешние СУБД поддерживают многопользовательский режим работы: несколько пользователей или процессов могут одновременно читать и изменять данные. И параллельное выполнение операций без соответствующих механизмов синхронизации может привести к некорректному состоянию базы данных и нарушению целостности данных \autocite{ElmasriNavathe, Silberschatz}.
Когда в базе данных одновременно выполняется несколько транзакций, свойство изоляции может больше не сохраняться. Чтобы обеспечить это, система должна контролировать взаимодействие между параллельными транзакциями. \autocite{Silberschatz}

\paragraph{Основные проблемы конкурентного доступа} ~\\

Конкурентный доступ может привести к следующим "аномалиям":
\begin{enumerate}
    \item Lost Update (Потерянное обновление) ~\\
    Возникает, когда два процесса работают с одной и той же записью, но изменения которые сделал первый процесс, перезаписываются вторым, и тем самым перваначальные данные теряются.
    
    Пример (условный):
    \begin{itemize}
        \item Дима считывает значение \texttt{Баланс = 100}.
        \item Вася считывает то же значение \texttt{Баланс = 100}.
        \item Дима увеличивает баланс на \texttt{+50} и записывает \texttt{Баланс = 150}.
        \item Вася увеличивает баланс на \texttt{+30} (но он не знает, что Дима уже внес изменения) и записывает \texttt{Баланс = 130}.
        \item Итог: операция Димы канула в небытие, и баланс становится \texttt{130}, хотя должен быть \texttt{180}.
    \end{itemize}

    \item Dirty Read (Несогласованое чтение) ~\\
    Процесс читает данные, которые уже были изменены, но еще не были зафиксированы другой транзакцией. И если эта та транзакция откатится, то прочитанные данные окажутся недействительными (точнее, они вообще по идее "никогда и не существовали").
    
    Пример:
    \begin{itemize}
        \item Изначально есть запись \texttt{Цена товара = 100}.
        \item Транзакция A обновляет \texttt{Цена товара = 200}, но \texttt{COMMIT} еще не выполнила.
        \item Транзакция B читает это \texttt{Цена товара = 200} и что-то делает дальше.
        \item Транзакция A делает \texttt{ROLLBACK}, возвращая \texttt{Цена товара = 100}.
        \item Иток: Транзакция B использовала неверные данные.
    \end{itemize}

    \item Non-repeatable Read (Неповторяющееся чтение) ~\\
    Происходит, когда транзакция повторно читает одну и ту же строку, но получает разные значения из-за того, что другая транзакция изменила или удалила эти данные и зафиксировала изменения.

    Пример:
    \begin{itemize}
        \item Транзакция A читает строку \texttt{id=1, balance=100} в таблице \texttt{accounts}.
        \item Транзакция B изменяет \texttt{balance} для \texttt{id=1} на 200 и выполняет \texttt{COMMIT}.
        \item Транзакция A снова читает \texttt{id=1} и получает \texttt{balance=200}, хотя в рамках одной транзакции ранее видела \texttt{balance=100}.
    \end{itemize}

    \item Phantom Read (Фантомное чтение) ~\\ 
    Явление считывания разных данных при одинаковом запросе. То есть процесс считывает набор данных (множество строк), потом делает повторный запрос, и видит новые или исчезнувшие записи из-за вмешательства (параллельного изменения этих данных) другой транзакции.

    Пример:
    \begin{itemize}
        \item Транзакция A запрашивает список сотрудников компании удовлетворяющих условию \texttt{зарплата < 30000}.
        \item Параллельно транзакция B добавляет нового сотрудника с \texttt{зарплата = 20000} и выполняется \texttt{COMMIT}.
        \item Транзакция A повторяет запрос и получает другой набор записей.
    \end{itemize}

    \item Race Condition (состояние гонки) ~\\
    Две транзакции "конкурируют" друг с другом за обновление одних и тех же данных без надлежащей синхронизации. Подобное может приветси к непредсказуемому порядку выполнения операций и некорректным результатам.

    Пример: ~\\
    Два пользователя одновременно покупают последний товар на складе. Оба видят, что товар есть в наличии (условно, \texttt{stock = 1}), оба оформляют заказ и уменьшают \texttt{stock = 0}. Как итог база данных зафиксировала две продажи, но товар был только один.

\end{enumerate}

\paragraph{Причины возникновения проблем параллельного доступа} ~\\
\begin{itemize}
    \item Использование низкого уровня изоляции транзакций (см. ниже).
    \item Отсутствие блокировок (см. ниже).
    \item Некорректное управление многопользовательским доступом, к примеру отключение администраторами СУБД механизмов блокировок или снижение уровня изоляции ради повышения производительности.
\end{itemize}

\subsubsection{Уровни изоляции транзакций}

Уровни изоляции транзакций определяют, насколько одна транзакция может видеть изменения, внесенные другой транзакцией, прежде чем они будут зафиксированы в БД. Это на самом деле спорный аспект любой многопользовательской работы с БД, т.к. всегда баланс между целостностью данных и производительностью системы требует компромиссов.

Стандарт SQL-92 определяет четыре уровня изоляции транзакций, каждый из которых решает определенные проблемы параллельного доступа \autocite{ElmasriNavathe, Silberschatz}:

\begin{table}[H]
    \centering
    \begin{tabular}{|c|p{4.25cm}|p{3.25cm}|p{3cm}|}
        \hline
        \textbf{Уровень изоляции} & \textbf{Описание} & \textbf{Метод реализации*} & \textbf{Используется по умолчанию} \\
        \hline
        \textbf{READ UNCOMMITTED} & Минимальный уровень изоляции, позволяющий одной транзакции видеть изменения, внесенные другой транзакцией, даже если они ещё не зафиксированы & Отсутствие блокировок & Почти не используется \\
        \hline
        \textbf{READ COMMITTED} & Транзакция видит только зафиксированные другими транзакциями изменения & Блокировки на уровне строк & PostgreSQL, Oracle, SQL Server \\
        \hline
        \textbf{REPEATABLE READ} & Гарантирует, что в рамках одной транзакции данные останутся неизменными & Блокировка строк на чтение и изменение & MySQL (InnoDB) \\
        \hline
        \textbf{SERIALIZABLE} & Максимальный уровень изоляции, полностью предотвращает параллельное выполнение транзакций. То есть обеспечивает выполнение транзакций так, будто они б выполнялись последовательно & Полная блокировка таблиц или снапшоты & PostgreSQL (опционально) \\
        \hline
    \end{tabular}
    \caption{Уровни изоляции транзакций и их характеристики}
    \label{tab:isolation_levels}
\end{table}
 *см. ниже "Принципы работы изоляции транзакций"

 Чем выше уровень изоляции, тем больше гарантирована целостность данных, но тем выше затраты на синхронизацию параллельно выполняемых транзакций

 \paragraph{Принципа работы изоляции транзакций} ~\\

 Изоляция обеспечивается за счет нескольких механизмов:
 \begin{enumerate}
     \item Механизмы блокировок (Locks) - транзакция блокирует строки или таблицы, другие транзакции не могут их изменять.
     \item MVCC (Multi-Version Concurrency Control) - транзакция работает с отдельными версиями строк, без блокировок.
     \item Снапшоты - механизм, при котором транзакция видит состояние БД на момент своего начала, независимо от других транзакций.
     \item Также иногда используется тема что вместо блокировок транзакции проверяют, не изменились ли данные с момента их первого чтения перед фиксацией изменений.
 \end{enumerate}
 
 \paragraph{Реализация уровней изоляции в разных СУБД} ~\\
 
 Каждая СУБД реализует изоляцию по-разному \autocites[§2]{PostgreSQLdocc13}[§17.7.2.1]{Mysqldoc4}{MicrosoftLearnSQLserverIsolation}{oracledbdoc5}
 
 \begin{enumerate}
     \item \textbf{PostrgeSQL} использует MVCC, по умолчанию работает в режиме READ COMMITTED, поддерживает SERIALIZABLE через снапшоты.
     \item \textbf{MySQL} по умолчанию REPEATABLE READ, использует gap locks для защиты от фантомного чтения.
     \item \textbf{SQL Server} поддерживает READ COMMITED SNAPSHOT, позволяет измежать блокировок при чтении.
     \item \textbf{Oracle} всегда работает в READ COMMITED, SERIALIZABLE реализуется через временные блокировки.
 \end{enumerate}
 
 Примеры установки уровня изоляции в разных СУБД:
 \begin{itemize}
     \item PostgreSQL
     \begin{lstlisting}[language=SQL]
         SET TRANSACTION ISOLATION LEVEL SERIALIZABLE;
     \end{lstlisting}
 
     \item MySQL
     \begin{lstlisting}[language=SQL]
         SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ;
     \end{lstlisting}
 
     \item SQL Server
     \begin{lstlisting}[language=SQL]
         SET TRANSACTION ISOLATION LEVEL READ COMMITTED;
     \end{lstlisting}
 
     \item Oracle
     \begin{lstlisting}[language=SQL]
         ALTER SESSION SET ISOLATION_LEVEL SERIALIZABLE;
     \end{lstlisting}
 
 \end{itemize}
 
 \paragraph{Влияние изоляции на производительность} ~\\
 
 Логично, что выбор уровня изоляции влияет на производительность базы данных. И зависимость тут не замысловатая - чем больше блокировок, тем больше задержки. То есть обычная обратная зависимость
 
 \begin{table}[H]
     \centering
     \begin{tabular}{|c|c|c|}
         \hline
         \textbf{Уровень изоляции} & \textbf{Количество блокировок} & \textbf{Скорость} \\
         \hline
         \textbf{READ UNCOMMITTED} & Минимум & Максимальная \\
         \hline
         \textbf{READ COMMITTED} & Средне & Высокая \\
         \hline
         \textbf{REPEATABLE READ} & Высокая & Средняя \\
         \hline
         \textbf{SERIALIZABLE} & Максимальная & Низкая \\
         \hline
     \end{tabular}
     \caption{Влияние уровней изоляции на блокировки и производительность}
     \label{tab:isolation_performance}
 \end{table}
 
 В этом плане самый адекватный вариант - READ COMMITED: адекватный баланс между скоростью и корректностью данных. SERIALIZABLE используется в критично важных операциях, и сильно замедляет работу системы.
 
 \subsubsection{Виды блокировок}
 
 Блокировки в СУБД представляют из себя механизм, обеспечивающий согласованность и целостность данных при параллельном выполнении транзакций. Они позволяют избежать нежелательных эффектов, которые возникают при параллельном доступе, описанные ранее (см. 3.4.1)
 
 Основная цель механизма блокировок – координация доступа к данным так, чтобы конкурирующие транзакции не нарушали согласованность базы данных. Без применения блокировок параллельные операции могут привести к повреждению данных или нарушению согласованности транзакционного процесса. Опять же, как уже было сказано ранее, если два пользователя попытаются одновременно изменить одну и ту же строку таблицы без блокировки, возможен сценарий потери обновлений.
 
 Разные блокировки применяются в зависимости от уровня объекта, на который они накладываются, и сценария их использования:
 
 \begin{itemize}
     \item Для \textbf{чтения} данных важно предотвращать их модификацию во время выполнения запроса, но при этом оставлить возможность другим транзакциям также читать эти данные
     \item Для \textbf{модификации} данных надо исключить параллельное изменение одного и того же объекта (-> более жесткая блокировка)
     \item Разные уровни блокировок (на уровне базы/таблицы/строки и тд) позволяют "балансировать" между безопасность и производительностью системы (чем более "гранулярна" блокировка, тем меньше влияние на параллельную обработку данных, но тем выше сложность управления ей) \autocite[ch.22]{ElmasriNavathe}
 \end{itemize}
 
 Теперь рассмотрим основные виды блокировок в зависимости от уровня их накладывания:
 
 \paragraph{Классификация блокировок по объекту} ~\\
 \subparagraph{Блокировка базы данных (Database Lock)} ~\\
 Является самой грубой формой блокировки, при которой вся база данных становится недоступной для изменения другими процессами. Применяется при административных операциях (например, при резервном копировнии с полным дампом данных), в случае каких-то глобальных изменений схемы (например, при изменении структуры БД), также долговременные аналитические запросы по идее также могут инициировать блокировку на уровне базы.
 
 Например, в MySQL команда \texttt{FLUSH TABLES WITH READ LOCK} накладывает глобальную блокировку базы данных, предотвращая запись, но оставляя чтение \autocite[§15.7.8.3]{Mysqldoc5}
 
 \subparagraph{Табличные блокировка (Table Lock)} ~\\
 Позволяют заблокировать всю таблицу, предотвращая внесение изменений другими транзакциями. Используется при долговременной обработке данных (к прмеру, при массовом обновлении или удалении) или, например, при изменении структуры таблицы.
 
 Примеры:
 \begin{itemize}
     \item В MySQL команда \texttt{LOCK TABLE employees WRITE} заблокирует табицу для всех операций кроме тех, что выполняются в текущей сессии \autocite[§15.3.6]{Mysqldoc5}.
     \item В PostgreSQL \texttt{LOCK TABLE employees IN ACCESS EXCLUSIVE MODE} накладывает строгую блокирвоку \autocite{PgReference1}.
     \item В SQL Server \texttt{TABLOCKX} используется для полной блокировки таблицы \autocite{MicrosoftLearnSQLserverTabHints}.
     \item В Oracle есть режим \texttt{SHARE MODE}, который предотвращяет модификации, но разрешает чтение \autocite[ch.18]{oracledbreference}.
 \end{itemize}
 
 \subparagraph{Блокировки строк (Row Lock)} ~\\
 Наиболее гибкий и эффективный вид блокировки: блокируется одна страка в таблице, а не вся таблица целиком. Используется в большинстве современных СУБД с поддержкой многоверсионности (MVCC): PostgreSQL, InnoDB (MySQL), SQLServer.
 Применятеся при изменении конкретной записи (\texttt{UPDATE}, \texttt{DELETE}), при параллельном доступе к одной таблице (если одна таблица обновляет строку а другая читает).
 
 Например, команда:
 \begin{lstlisting}[language=SQL]
     SELECT * FROM accounts WHERE id = 5 FOR UPDATE;
 \end{lstlisting}
 Она накладывает блокировку на строку, предотвращая изменение другими транзакции. В Postgre что в MySQL команда оденаковая
 В SQL Server можно еще предотвратить конфликтные обновления с помощью \texttt{\detokenize{WITH (UPDLOCK)}} \autocite{MicrosoftLearnSQLserverTabHints}
 
 \subparagraph{Блокировки индексов (Index Lock)} ~\\
 Блокировки индексов - отдельный вид блокировки, который накладывается не на данные, а на индексы, когда они обновляются. То есть или когда надо избежать конфликтов при пересчете индексов при добавлении новых записей (\texttt{INSERT}), или при обновлении индексов при изменении значений ключевых полей.
 
 Например, если у нас есть \texttt{PRIMARY KEY} или \texttt{UNIQUE} индекс, СУБД проверяет, существует ли уже такое значение. Или если несколько транзакций, одновременно которые пытаются вставить разные строки с одинаковым ключевым значением, тоже возникает конфликт. Например:
 \begin{lstlisting}[language=SQL]
     INSERT INTO users (id, name) VALUES (5, 'Alice');
     INSERT INTO users (id, name) VALUES (5, 'Bob');
 \end{lstlisting}
 В данном случае, во второй строке блокировка индекса, конфликт по PRIMARY KEY. Первый \texttt{INSERT} успешно проходит, а второй будет ждать пока индекс не освободится.
 
 Если обновление записей (\texttt{UPDATE}), затрагивающее индексированные поля, например, если транзакця изменяет значение столбца, который входит в индекс, индекс должен быть обновлен. Это может привести к блокировке, так как надо сначала найти старое значение в индексе а затем заменить его новым.
 \begin{lstlisting}[language=SQL]
     UPDATE users SET id = 10 WHERE id = 5;
 \end{lstlisting}
 Если другая транзакция попробует обновить \texttt{id = 5} в этот же момент, она будет заблокирована до завершения первой.
 
 С удалением записей \texttt{DELETE} то же самое что и с \texttt{UPDATE}.
 
 \subparagraph{Блокировки страниц (Page Lock)} ~\\
 Промежуточный уровень между Row Lock и Table Lock. Применяется, когда необходимо ограничить доступ к группе строк, хранящихся на одной странице в памяти или на диске. Например, когда блокировка всей таблицы избыточна, а построчная блокировка слишком затратная.
 
 Каждая страница в базе данных обычно имеет фиксированный размер (например, 8 КБ в SQL Server и Oracle), и хранит несколько записей. При блокировке страницы все данные внутри неё становятся недоступными для изменений другими транзакциями.
 
 Особенно полезна блокировка страниц в следующих сценариях: при массовых обновлений, когда транзакция обновляет или удаляет большое количество строк, и блокировка каждой строки отдельно весьма накладна, и вместо этого СУБД может заблокировать целую страницу, содержащую эти строки, чтоб минимизировать количество операций блокировки.
 Пример кода:
 \begin{lstlisting}[language=SQL]
     UPDATE Orders
     SET status = 'shipped' 
     WHERE order_date < '2024-01-01';
 \end{lstlisting}
 Если вот эта вот команда затрагивает тысячи записей, то СУБД модет применить блокировку страниц, чтобы не блокировать каждую строку отдельно
 
 \paragraph{Классификация блокировок по типу доступа} ~\\
 
 Ключевые типы блокировок включают разделяемые (SHARED, S-LOCK), исключительные (EXCLUSIVE, X-LOCK), блокировки обновления (UPDATE LOCK) и намеренные блокировки (INTENT LOCKS)
 Рассмотрим каждый из них в отдельности.
 
 \subparagraph{1. Разделяемая блокировка (SHARED LOCK, S-LOCK)} ~\\
 S-LOCK позволяет нескольким транзакциям читать одни и те же данные, но запрещает их изменение, пока не будет снята \autocite{ElmasriNavathe}.
 Например, транзакция получает разделяемый доступ, когда выполняется \texttt{SELECT ... FOR SHARE} в PostgreSQL, \texttt{LOCK IN SHARE MODE} в MySQL или аналог в других СУБД.
 Подобная махинация позволяет предотвратить изменения данных в процессе их анализа.
 
 Работает следующим образом: 
 Если один пользователь читает строку с S-LOCK, другие пользователи тоже могут ее читать (ставить свои S-LOCK), но если кто-то попытается изменить данные (\texttt{UPDATE}, \texttt{DELETE}), то система заставит его ждать, пока все S-LOCK не будут сняты.
 
 Пример (PostgreSQL)
 \begin{lstlisting}[language=SQL]
     BEGIN;
     SELECT * FROM orders WHERE id = 5 FOR SHARE;    
 \end{lstlisting}
 Этот запрос заблокирует запись \texttt{orders.id =5} от изменений, но другие транзакции все равно смогут ее читать.
 
 Для MySQL это будет выглядеть так:
 \begin{lstlisting}[language=SQL]
     SELECT * FROM orders WHERE id = 5 LOCK IN SHARE MODE;  
 \end{lstlisting}
 
 Проблема тут может возникнуть, если кто-то ждет X-LOCK, а другая транзакция долго держит S-LOCK, тогда возникает долгое ожидание
 
 \subparagraph{2. Исключительная блокировка (EXCLUSIVE LOCK, X-LOCK)} ~\\
 
 Блокировка полностью запрещает доступ другим транзакциям, то есть другие транзакции не могут ни читать, ни изменять строку, заблокированную X-LOCK, пока блокировка не будет снята.
 При \texttt{UPDATE}, \texttt{DELETE}, \texttt{INSERT} СУБД автоматически накладывают X-LOCK на изменяемые строки чтоб никакая другая транзакция не смогла получить доступ к изменяемым данным, пока операция не завершится
 То есть в случае (MySQL):
 \begin{lstlisting}[language=SQL]
     UPDATE orders SET status = 'Sent' WHERE id = 5; 
 \end{lstlisting}
 После выполнения UPDATE строка \texttt{orders.id =5} будет автоматически заблокирована X-LOCK и никто не сможет ее читать или менять пока транзакция не завершится.
 
 Когда X-LOCK накладывается на строку, другие транзакции ждут, пока она освободится. Также X-LOCK не конфликтует с самой собой, одна транзакция может сама несколько раз заблокировать одну строку без проблем.
 То есть условно (PostgreSQL):
 \begin{lstlisting}[language=SQL]
     BEGIN;
     SELECT * FROM employees WHERE id = 1 FOR UPDATE;
     SELECT * FROM employees WHERE id = 1 FOR UPDATE;
     COMMIT;    
 \end{lstlisting}
 Тут второй \texttt{FOR UPDATE} (повторный X-LOCK на одну и ту же строку) не приведет к конфликту, потому что оба запроса выполняются в одной транзакции. То есть СУБД распознает, что блокировка уже принадлежит той же транзакции, и просто увеличит счетчик блокировок, а не заблокирует саму себя.
 
 \subparagraph{3. Блокировка обновления (UPDATE LOCK)} ~\\
 
 Специальный вид блокировки, он предотвращает взаимоблокировки при обновлении данных.
 Например, если какая-то транзакция делает \texttt{SELECT ... FOR UPDATE} и ждет, другая транзакция делает также \texttt{SELECT ... FOR UPDATE} на ту же строку и тоже ждет, то обе транзакции зависают потому что обе ждут снятия блокировки у другой (deadlock). 
 Соответственно \texttt{UPDATE LOCK} преднозначен для снижения вероятности deadlock: если транзакция использует \texttt{UPDATE LOCK}, то другие транзакции могут читать данные, но не могут их обновлять.
 
 Пример наложения \texttt{UPDATE LOCK} на \texttt{orders.id=5} (PostgreSQL)
 \begin{lstlisting}[language=SQL]
     SELECT * FROM orders WHERE id = 5 FOR UPDATE;
 \end{lstlisting}
 
 \subparagraph{4. Намеренные блокировки (INTENT LOCKS, I-LOCKS)} ~\\
 
 В SQL Server для согласованности блокировок между разными уровням данных используются блоирковие \texttt{INTENT LOCKS}. \autocite{MicrosoftLearnSQLserverTransLock}
 
 Если транзакция хочет поставить \texttt{X-LOCK} на строку, она сначала должна поставить XI-LOCK (\texttt{INTENT EXCLUSIVE LOCK}) на таблицу. Если она хочет поставить \texttt{S-LOCK} на строку, то сначала она должна поставить \texttt{IS-LOCK} (\texttt{INTENT SHARED LOCK}) на таблицу.
 
 Это нужно, чтобы избежать конфликтов между блокировками разных уровней. Например, если кто-то хочет заблокировать всю таблицу, но есть \texttt{I-LOCK} на отдельные строки, то таблица не заблокируется до освобождения всех строк.
 
 \begin{lstlisting}[language=SQL]
     SELECT * FROM orders WITH (HOLDLOCK);
 \end{lstlisting}
 
 Здесь ставится \texttt{IS-LOCK} на таблицу и \texttt{S-LOCK} на строки.

\paragraph{Эскалация блокировок} ~\\

Количество блокировок, которые может потребоваться установить SQL-запросу, как правило, можно предварительно оценить на основе того, какие операции сканирования реляционных объектов (relation scan) он выполняет. Например, если запрос сканирует всю таблицу, то чаще всего будет установлена блокировка на уровне всей таблицы (relation-level lock). Если же предполагается использовать индексное сканирование для извлечения небольшого количества записей, то может быть установлена намеренная блокировка (intention lock) на уровне таблицы и обычные блокировки на уровне отдельных кортежей (строк). Однако если транзакция начинает захватывать слишком большое количество блокировок на уровне строк, это может привести к переполнению внутренней таблицы блокировок (lock table), которую использует менеджер блокировок для хранения информации о текущих захватах. Чтобы избежать исчерпания ресурсов, менеджер блокировок может выполнить так называемую \textbf{эскалацию блокировок} — замену множества мелких (например, строковых) блокировок одной более крупной, например, блокировкой всей таблицы. \autocites[ch.18]{Silberschatz}

\begin{grayquote}
    \textbf{Эскалация блокировок} - процесс автоматического перевода множества мелких блокировок (например, на уровне строк) в более крупную блокировку (например, всей таблицы или страницы памяти), когда количество мелких блокировок превышает установленный порог. Этот механизм используется чтобы уменьшить накладные расходы на управление блокировками и сыкономить ресурсы системы.
\end{grayquote}

Зачем оно надо?
\begin{itemize}
    \item Снижение затрат ресурсов, поскольку каждая блокировка требует памяти и времени, и если транзакция блокирует тысячи строк, то это может перегрузить менеджер блокировок.
    \item Менеджеру блокировок проще и быстрее принять решение, управляя одной крупной блокировкой, чем многими мелкими.
    \item Эскалация может уменьшить количество конкурентных блокировок и тем самым снизить вероятность взаимоблокировок.
\end{itemize}

Однако такая замена увеличивает вероятность конфликта между транзакциями, так как крупнозернистая блокировка ограничивает параллелизм работы \autocite{MicrosoftLearnSQLserverTransLock}
Как пример, рассмотрим SQL Server. В нем эскалация блокировок инициируется в следующих случаях \autocite{MicrosoftLearnSQLserverTransLock}:
\begin{itemize}
    \item Если один Transact-SQL-запрос получает 5000 или более блокировок на одной таблице (или разделе таблицы).
    \item Если общая память, используемая для блокировок в инстансе SQL Server, превышает определённый порог (например, 24\% от доступной памяти при \texttt{locks = 0}).
    \item Также повторные попытки эскалации выполняются каждые 1250 новых блокировок при условии, что изначальная попытка не удалась.
\end{itemize}

Рассмотрим код:
\begin{lstlisting}[language=SQL]
    BEGIN TRANSACTION;
    UPDATE employees
    SET salary = salary * 1.1
    WHERE department = 'IT';
\end{lstlisting}
Если под условие \texttt{WHERE department = 'IT'} попадеат более 5000 строк, SQL Server может инициировать эскалацию, заменив множество \texttt{ROW}-блокировок одной \texttt{TABLE}-блокировкой уровня \texttt{X} (эксклюзивной). Все предыдущие блокировки на строки, страницы и индексы в рамках таблицы \texttt{employees} будут при этом сняты.

Стоит также отметить следующий моменты:
\begin{itemize}
    \item Система не выполняет эскалацию до уровня страниц (только до уровня таблицы).
    \item При успешной эскалации все более мелкие блокировки заменяются одной более крупной.
    \item Если необходмая блокировка таблицы не может быть получена (например, из-за конфликта с другой транзакцией), то \textbf{эскалация не выполняется}, и система продолжает устанавливать мелкие блокировки.
\end{itemize}

Настроить или отключить эту штуку можно через \texttt{ALTER TABLE ... SET (LOCK ESCALATION = ...)}.

Например так:
\begin{lstlisting}[language=SQL]
    ALTER TABLE employees SET (LOCK_ESCALATION = DISABLE);
\end{lstlisting}

\paragraph{Временные блокировки} ~\\

Еще одним из простых, но при этом эффективных механизмов борьбы с зависаниями транзакций является использование тайм-аутов блокировок (lock timeouts). Суть подхода заключается в том, что транзакция, запросившая ресурс, не ждет его бесконечно. Вместо этого система предоставляет ей только ограниченное количество времени на ожидание. Если к этому моменту доступ не предоставлен, транзакция автоматически прерывается и откатывается. \autocite[ch.18]{Silberschatz}

Таймауты блокировок по сути это гибридная стратегия между \textbf{предотвращением взаимоблокировок (deadlock prevention)} (где система проектируется так, чтобы такие ситуации не возникали) и \textbf{обнаружением и устранением взаимоблокировок (deadlock detection and recovery)} (где deadlock'и допускаются, но при этом отслеживаются и устраняются системой).

Когда транзакция сталкивается с невозможностью получить нужный ей ресурс втечении заданного времени, считается что оно зависло либо из-за deadlock'а или изза длительного ожидания, и выполняется откат (\texttt{ROLLBACK}) транзакции, тем самым освобождая рисурсы и позволяя другим операциям продолжиться.

\begin{grayquote}
    \textit{«Если транзакция ожидает блокировку дольше допустимого времени, она откатывается. Это снижает вероятность зацикливания и помогает системе быстрее восстановиться при взаимоблокировке»} \autocite[ch.18]{Silberschatz}
\end{grayquote}

К плюсам подобного подхода следует отнести простоту реализации, эффективность при коротких транзацкиях, а также автоматичискуб очистку зависших операций.
Из минусов - требуется точная настройка времени ожидания. Слишком короткий таймаут приведет к излишним rollback'ам даже без deadlock, а слишком длинный заадержит обнаружениие реальной проблемы. \autocite[ch.22]{ElmasriNavathe}

В PostgreSQL можно задать максимальное время ожидания блокировки при помощи параметра \texttt{lock\_timeout} \autocite[§19.11]{PostgreSQLdocc19}:
\begin{lstlisting}[language=SQL]
    SET lock_timeout = '2s';
    BEGIN;
    UPDATE employees SET salary = salary + 1000 WHERE id = 1;
    COMMIT;
\end{lstlisting}
Здесь установлено максимум 2 секунды ожидания блокировки, и дальше идет попытка обновить сторку которая уже заблокирована другой транзакцией. И если строка \texttt{id = 1} заблокирована другой транзакцией, и блокировка не освобождается в течение 2 секунд, то тогда PostgreSQL автоматически выдаст ошибку и откатит текущую транзакцию:
\begin{lstlisting}[language=]
    ERROR: canceling statement due to lock timeout
\end{lstlisting}

В MySQL параметр \texttt{innodb\_lock\_wait\_timeout} (по умолчанию 50 секунд) задает максимальное время ожидания блокировки. Превышение лимита вызывает откат транзакции с ошибкой \texttt{Lock wait timeout exceeded} \autocite[§17.14]{Mysqldoc4}.

В SQL Server оператор \texttt{SET LOCK\_TIMEOUT} \autocite{MicrosoftLearnSQLserverSetLockTout} задает время ожидание \textbf{в милисикундах} (1000 мс = 1с):
\begin{lstlisting}[language=SQL]
    SET LOCK_TIMEOUT 2000;
    BEGIN TRANSACTION;
    UPDATE employees SET salary = salary + 1000 WHERE id = 1;
    COMMIT;
\end{lstlisting}
Если таймаут превышен, возникает ошибка:
\begin{lstlisting}[language=]
    Msg 1222, Level 16, State 51
    Lock request time out period exceeded.    
\end{lstlisting}


\subsubsection{Протоколы блокировок}

Протоколы управления блокировками - это набор правил и/или алгоритмов, которые регулируют порядок захвата и освобождения блокировок транзакциями. Основная их цель - обеспечить соглаосванности данных, предотвратитт аномалии возникающие при прараллельном доступе и гарантировать сериализуемость (то есть такую историю выполнения транзакций которая эквиволент их некоорому последовательному (однопоточному) выполнению).
Наиболее самым ширроко используемый это двухйазный протокол блокировок (2PL) который обиспечивает коректное взаимодейтсвие транзакций путем строго регламенированной последовательности блокировок и и освобождения7 Однако его использование может привести к \texttt{deadlocks}.


\paragraph{Двухфазный протокол блокировок (2PL)} ~\\


Двухфазный протокол блокировок (Two-Phase Locking, 2PL) - один из наиболее известных и широко используемых протоколов управления паралелизмом транзакций в реляционных СУБД. Основаня задача протокола - обеспичеть сериализуемость, то есть согласованное выполняемое транзакции в много полльзовательскоц среде, исключая нежилательные аномалии достуап к данных.

Протокол 2PL делит жизненный цикл транзакции на две чётко разграниченные фазы \autocite[ch.18 §1.3]{Silberschatz}:

\begin{enumerate}
    \item Фаза захвата (growing phase) - транзакция может только запрашивать ноыые бллокировки, но не может снимать уже полученные
    \item Фаза освобождания (shrinking phase) - транзакция может только освобождать блокировки, но не может запрашивать новые
\end{enumerate}

Как только транзакция наченает снимать хотя бы одну блокировку то она переходит из фазы захвата в фазу освобождения и теряет возможность получать новые блокировки, и это правило строго ограничивает поведение транзакции и обеспечивает корректное взаимодействие с другими транзакциям (делает поведение транзакции предсказуемым \textrightarrow исключает аномалии которые могли бы возникнуть при произвольном порядке захвата и снятия блокировок). \autocites[ch.18 §1.3]{Silberschatz}[ch.22 §1.2]{ElmasriNavathe}

Основной идеей протокола 2PL является то, что все необходимые блокировки долдны быть получины до начала их освобождения. Таким образом блокировки накладываются как бы в «в рост», а затем «спадают». Это приводит к тому что вся работа с данными (и потенциальные конфликты) контролируются до того как транзакция начнет отпускать ресурсы. Это обеспечивает изоляцию и согласованность. \autocite[ch.18 §1.3]{Silberschatz}

Рассмотрим конкретную ситуацию в которой участвуют две транзакции T1 и T2, обе работающие с двумя объектами A и B:
\begin{table}[H]
    \centering
    \begin{tabular}{|p{7cm}|p{7cm}|}
        \hline
        \textbf{Транзакция T1} & \textbf{Транзакция T2} \\
        \hline
        \begin{lstlisting}[language=SQL]
            LOCK A;
            READ A;
            LOCK B;
            WRITE B;
            UNLOCK B;
            UNLOCK A;
        \end{lstlisting}
        &
        \begin{lstlisting}[language=SQL]
            LOCK B;
            READ B;
            LOCK A;
            WRITE A;
            UNLOCK A;
            UNLOCK B;
        \end{lstlisting} \\
        \hline
    \end{tabular}
    \caption{Параллельное выполнение транзакций с конфликтом блокировок}
    \label{tab:conflict_transactions}
\end{table}
    
То есть T1 сначала захватывает \texttt{A}, а затем \texttt{B}. T2 сначала захватывает \texttt{B}, затем пытается захватить \texttt{A}.
В этой ситуации возможна взаимоблоировка: T1 удерживает \texttt{A} и ждет \texttt{B}, T2 удерживает \texttt{B} и ждет \texttt{A}.

Каждая транзакция «держит» один ресурс и «ждёт» другой, что создает циклическую зависимость (\texttt{deadlock})
Однако важно отметить, что не смотря на вохможность deadlock'ов, протокол 2PL гарантирует сериализуемость, то есть даж если необходимость отката или ожидания, пордок операций будет согласован с некоторой последовательной историей выполенния.

\subparagraph{Ключевые правила перехода между фазами} ~\\
 В момент транзакцией совершения хотя бы одной блокировки, она считается перешедшей во вторую фазу - и на всегда теряет возможность захвата новых блокировок. Любвя попытка получить блокировку в фазе освобождения считается нарушение 2PL-протокола.
 Это приводить к следющим последствиям:
 \begin{itemize}
    \item Транзакции обязаны планировать блокирвоки заранее
    \item После начала освобождения ресурсов поведение становится только освобождающим
    \item Эти моменты исключают повторные захваты, и тем самым типа делаит поведеление транзакции безопасно с точки зрения изоляции \autocite[ch.22]{ElmasriNavathe}
 \end{itemize}

\subparagraph{Решение проблемы взаимоблокировок} ~\\

 СУБД обычно решают проблему взаимоблокировок одним из следующих образов \autocite{Silberschatz}:
 \begin{enumerate}
    \item detection\&recovery - построение графа оджидания и прерывание одной из транзакций
    \item prevention - навязывание порядка захвата ресурсов дабы исключить циклы
    \item таймауты (прирывание транзакции если она ждет слишком долго)
 \end{enumerate}

 \paragraph{Вариации двухфазного протокола} ~\\

 Протокол 2PL имеет несколько вариаций: строгий и сирьезный
 
 \subparagraph{Строгий двухфазный протокол блокировок (Strict 2PL)} ~\\
 
 Strict Two-Phase Locking Protocol это наи более часто применяемый на практике вариант, который обепечивает как сериализуемость так и восстановимость транзакций
 
 \begin{grayquote}
     В Strict 2PL транзакция не освобождает ни одной эксклюзивной блокировки (X) до тех пор, пока не выполнен COMMIT или ROLLBACK \autocite{Silberschatz}
 \end{grayquote}
 
 При этом блокировки на чтение (S - shared) могут быть освобождени до завершения транзакции
 
 Присер:
 Допустим, транзакция обновляет таблицу:
 
 \begin{lstlisting}[language=SQL]
     BEGIN;
     UPDATE accounts SET balance = balance - 100 WHERE id = 1;
     COMMIT;    
 \end{lstlisting}
 До выполнения \texttt{COMMIT} ни одна другая тразныкция не сможет прочитать или изменить эту страку, поскольку транзакция все еще удерживает эксклюзивную блокировку до момента \texttt{COMMIT}
 Из плюсов: гарантия сериализуемости и обеспечение восстановимости, так как ни какая другая транзакция не смоэет прочитать "грязные" неподтвержденные данные
 
 \subparagraph{Серьезный двухфазный протокол блокировок (Rigorous 2PL)} ~\\
 
 Rigorous Two-Phase Locking Protocol это ещё более ограничительная версия, чем strict 2PL \autocite{Silberschatz}
 
 \begin{grayquote}
     В Rigorous 2PL ни одна блокировка (ни shared, ни exclusive) не освобождается до конца транзакции. 
     То есть, как блокировки на чтение (S), так и на запись (X) держатся до \texttt{COMMIT} или \texttt{ROLLBACK}. \autocite{Silberschatz}
 \end{grayquote}
 
 \begin{table}[H]
     \centering
     \begin{tabular}{|l|c|c|c|}
         \hline
         \textbf{Характеристика} & \textbf{Обычный 2PL} & \textbf{Strict 2PL} & \textbf{Rigorous 2PL} \\
         \hline
         Гарантия сериализуемости & Да & Да & Да \\
         \hline
         Гарантия восстановимости (recoverability) & Нет & Да & Да \\
         \hline
         Чтение "грязных" данных (dirty reads) возможно? & Да & Нет & Нет \\
         \hline
         Отпускание S-блокировок до COMMIT & Да & Да & \textbf{Нет} \\
         \hline
         Отпускание X-блокировок до COMMIT & Да & \textbf{Нет} & \textbf{Нет} \\
         \hline
         Частота взаимоблокировок & Низкая & Средняя & Высокая \\
         \hline
         Простота реализации & Высокая & Средняя & Средняя \\
         \hline
     \end{tabular}
     \caption{Сравнение вариантов двухфазного протокола блокировок}
 \end{table}
 
 \paragraph{Протоколы предотвращения взаимоблокировок (Deadlock Prevention Protocols)} ~\\
 
 В СУБД, использующих блокировки, логично что всегда существует риск возникновения взаимоблокировок (deadlock). Напомним, что это ситуация когда несколько транзакций ждут друг друга и ни одна не может продолжит выполняться. Один из подходов к решениб этой проблемы - предотвращение взаимоблокировок заранее, до того как они возникнут.
 
 Для этого применяются специальные протоколы предотвращения взаимоблокировок, которые основаны на управлении порядком полученияя блокировок и решениях о \texttt{ROLLBACK}. \autocite{Silberschatz, ElmasriNavathe}
 
 \subparagraph{1. Протокол Wait-Die} ~\\
 
 Wait-Die — неконсервативный протокол предотвращения взаимоблокировок, который использует временные метки транзакций и применяет стратегию «ждать или сдохнуть» (wait or die)
 
 Каждая транзакция при старте получает уникальную временную метку, определяющую её «возраст» (чем раньше началась транзакция — тем она «старше»).
 
 Когда транзакция \texttt{T\_i} хочет захватить блокировку, уже удерживаемую другой транзакцией \texttt{T\_j}, система сравнивает их возраст \autocite{Silberschatz, ElmasriNavathe}:
 \begin{itemize}
     \item Если \texttt{T\_i} страше чем \texttt{T\_j} (то есть \texttt{T\_i.timestamp < T\_j.timestamp}), то \texttt{T\_i} ожидает (wait)
     \item Если же \texttt{T\_i} младше \texttt{T\_j}, то \texttt{T\_i} немедленно откатывается (die/rollback)
 \end{itemize}
 
 Пример:
 Пусть у транзакции \texttt{T1} временная метка =10, у \texttt{T2} - 20. Пусть \texttt{T1} удерживает блокировку на \texttt{A}. \texttt{T2} хочет захватить \texttt{A}, но она моложе, поэтому \texttt{T2\textrightarrow ROLLBACK}. Если наоборот \texttt{T1} хочет захватить объект, заблокировнный \texttt{T2}, то она ждет.
 
 То есть это простой в реализации протокол, но он может вызывать частные откаты младших транзакций.
 
 \subparagraph{2. Протокол Wound-Wait} ~\\
 
 Wound-Wait — альтернативный протокол, тоже использующий временные метки, но с другой логикой «ранить или ждать»
 
 Идея протокола \autocite{Silberschatz, ElmasriNavathe}:
 \begin{itemize}
     \item Если \texttt{T\_i} старше \texttt{T\_j}, то \texttt{T\_i} «ранит» \texttt{T\_j} (wound)
     \item Если \texttt{T\_i} младше \texttt{T\_j}, то оно ждет, пока \texttt{T\_j} не освободит ресурс (wait)
 \end{itemize}
 
 Пример:
 \texttt{T1} старше, \texttt{T2} моложе. \texttt{T2} захватила \texttt{B}, \texttt{T1} хочет тоже. \texttt{T1} старше\textrightarrow \texttt{T1} «ранит» \texttt{T2}\textrightarrow \texttt{T2\textrightarrow ROLLBACK} 
 
 Более агресивен, чем Wait-Die в плане прерывания работы "младших", позволяет старым транзакциям быстрее завершаться.
 
 \begin{table}[H]
     \centering
     \caption{Сравнение протоколов Wait-Die и Wound-Wait}
     \begin{tabular}{|l|p{5.25cm}|p{5.25cm}|}
         \hline
         \textbf{Характеристика} & \textbf{Wait-Die} & \textbf{Wound-Wait} \\
         \hline
         Тип решения & Транзакция ожидает или откатывается & Транзакция откатывает другого или ждёт \\
         \hline
         Кто откатывается & Молодая транзакция & Молодая транзакция \\
         \hline
         Поведение при конфликте & Старшая ждёт, младшая откатывается & Старшая прерывает младшую \\
         \hline
         Вероятность откатов & Средняя & Высокая (более агрессия) \\
         \hline
         Подходит для & Транзакций с длительным временем ожидания & Высокоприоритетных (старших) транзакций \\
         \hline
     \end{tabular}
 \end{table}
 
 \subparagraph{Консервативный подход (Conservative 2PL)} ~\\
 Оба вышеперчисленных рассмотренных протоколаа относятся к неконсервативным, потомк что позволяют транзакциям захватывать блокировки по мере необходимости, хотя и с контрольной логикой.
 
 Консервативный подход же заключается в следующем \autocite{Silberschatz, ElmasriNavathe}:
 \begin{itemize}
     \item Транзакция сначала запрашивает ВСЕЕ необходимые блокировки прежде чем начать выполнение
     \item Если ец не удалось получить все блокировки, то она ожидает ничего не делая
     \item Исключает deadlock \textbf{полностью}
 \end{itemize}
 
 \begin{table}[H]
     \centering
     \caption{Сравнение консервативного и неконсервативных протоколов}
     \begin{tabular}{|p{5cm}|p{5cm}|p{5cm}|}
         \hline
         \textbf{Характеристика} & \textbf{Консервативный 2PL} & \textbf{Wait-Die / Wound-Wait} \\
         \hline
         Подход & Захват всех блокировок сразу & Захват по мере необходимости \\
         \hline
         Гарантия отсутствия взаимоблокировки & Да & Да (по алгоритму) \\
         \hline
         Гибкость & Низкая & Высокая \\
         \hline
         Параллелизм & Низкий & Выше \\
         \hline
         Откаты & Отсутствуют & Возможны \\
         \hline
         Реализация & Требует знания всех блокировок ресурсов заранее & Проще реализовать \\
         \hline
     \end{tabular}
 \end{table}
     
 \begin{table}[H]
     \centering
     \caption{Преимущества и недостатки протоколов предотвращения взаимоблокировок}
     \begin{tabular}{|l|p{6cm}|p{6cm}|}
         \hline
         \textbf{Протокол} & \textbf{Преимущества} & \textbf{Недостатки} \\
         \hline
         Wait-Die & Простота реализации, предотвращение deadlock & Частые откаты у младших транзакций \\
         \hline
         Wound-Wait & Приоритет старших транзакций, быстрое завершение приоритетных операций & Агрессивная политика, возможные "жесткие" откаты \\
         \hline
         Консервативный 2PL & Исключение взаимоблокировок, логическая простота & Слабый параллелизм, неэффективен при заранее неизвестных ресурсах \\
         \hline
     \end{tabular}
 \end{table}
    
\paragraph{Протоколы таймштампов (Timestamp-Based Protocols)} ~\\

Протоколы управления параллелизмом, основанные на таймштампах (timestamp-based protocols) представляют собой альтернативу протоколам блокировок. В отличие от двухфазной блокировки (2PL), где порядок операций определяется во время исполнения, здесь порядок транзакций устанавливается заранее на основе уникальных временных меток, назначаемых каждой транзакции до её начала.

Каждой транзакции $T_i$ до начала выполнения назначается уникальный timestamp $TS(T_i)$ — числовое значение, отражающее "момент появления" транзакции в системе. Timestamp можеит быть сгенерирован двумя способами \autocite[ch.18 §5]{Silberschatz}:
\begin{enumerate}
    \item На основе \textbf{значения системных часов} в момент начала транзакции (например значение в милисекундах с начала эпохи Unix)
    \item С помощью глобального \textbf{счетчика}, который увиличивается при каждой новой транзакции 
\end{enumerate}

Таймштампы опридиляют сериализуемый порядок транзакций, типа если $TS(T_i) < TS(T_j)$, то транзакция $TS(T_i)$ должна предшествовать $TS(T_j)$ в расписании.

Например, пусть в систему вошли транзакции $T_1$, $T_2$, $T_3$, и получили таймштампы $TS(T_1) = 100, TS(T_2) = 105, TS(T_3) = 110$. Тогда тепер СУБД должна гарантировать что в итоговом исполнении порядок транзакций будет эквивалентен такому последовательности: $T_1 \rightarrow T_2 \rightarrow T_3$.

\subparagraph{Метки времени для данных} ~\\
Для реализации протокола с метками времени, каждая запись (объект данных) $Q$ должна хранить два значения:

\begin{itemize}
    \item $W_{\text{timestamp}}(Q)$ - максимальный таймштамп среди всех транзакций, успешно выполнивших запись в $Q$
    \item $R_{\text{timestamp}}(Q)$ - максимальный таймштамп среди всех транзакций, успешно выполнивших чтение из $Q$
\end{itemize}


Эти значения обновляются каждый раз, когда с объектом данных происходит операция чтения или записи. Они позуоляют системе проверить не нарушит ли новая операция установленный порядок

\subparagraph{Timestamp Ordering Protocol} ~\\

Протокол гарантирует что все конфлктующие операции выполняются в порядке меток времени. Суть протокола в том, что каждоая операция транзакции проверяется на допустимость в соответствии с ее таймштампом и состоянием данных. Протокол работает следующим образом \autocite{Silberschatz}:

\begin{itemize}
    \item Если транзакция $T_i$ выполняет операуцию чтения (\texttt{read($Q$)})
    \begin{itemize}
        \item Если $TS(T_i) < W_{\text{timestamp}}(Q)$, значит что транзакция пытаться прочитать значение которое уже было пеерзаписано более новой транзакцией, а следовательно чтении старой версии недопустимо и операция отклоняется а $T_i$ откатывается (\texttt{ROLLBACK})
        \item В противном случае выполняется чтение, а $R_{\text{timestamp}}(Q)$ обновляется до $max(R_{\text{timestamp}}(Q), TS(T_i))$
    \end{itemize}

    \item Если транзакция $T_i$ выполняет операуцию записи (\texttt{write($Q$)})
    \begin{itemize}
        \item Если $TS(T_i) < R_{\text{timestamp}}(Q)$, значит что уже была транзакция которая прочитала "новое" ("будущее") значение и операция отклоняется а $T_i$ откатывается (\texttt{ROLLBACK})
        \item Если $TS(T_i) < W_{\text{timestamp}}(Q)$, то $T_i$ пытается записать устаревшее значение (на данный момент кто-то уже записал в $Q$ новое значение) - также откат
        \item В противном случае запись выполняется, и $W_{\text{timestamp}}(Q)$ обновляется до $TS(T_i))$ 
    \end{itemize}
\end{itemize}

При этом транзакция, которая была откатана, получает новый таймштамп и повторяется

Пример. Рассмотрим две транзакции:
\begin{itemize}
    \item $T_1$ показывает сумму на счетах $A$ и $B$:
    \begin{lstlisting}[language=SQL]
        read(B);
        read(A);
        display(A + B);           
    \end{lstlisting}

    \item $T_2$ переводит 50 условных единиц со сяета $B$ на счет $A$:
    \begin{lstlisting}[language=SQL]
        read(B);
        B := B - 50;
        write(B);
        read(A);
        A := A + 50;
        write(A);
        display(A + B);               
    \end{lstlisting}
\end{itemize}

Если $TS(T_1) < TS(T_2)$, то протокол допускает выполнение всех операций в этом порядке. Но в ситуации где операции пересекаются и нарушают порядок по таймштампам (например $T_2$ начнет изменять данные прочитанные $T_1$ до завершения $T_1$ \textrightarrow возможен конфликт), одна из транзакций ($T_2$) будет откатана. Дабы обеспечить конфликтную сериализуемость

\subparagraph{Преимущества и недостатки} ~\\
Плюсы:
\begin{itemize}
    \item Отсутствие deadlock - никакая транзакция не ждет ресурс, так как при конфлиекте проиходит откат
    \item Гарантирована сериализуемость
\end{itemize}

Минусы:
\begin{itemize}
    \item Возможность "голодания" (starvation), так как длинная транзакция может много раз откатываться изза короткиз конфликтующих транзакций
    \item Слишком много откатов может привести к траблам с производительностью
    \item Необратимость (при записи может быть трудно реализовать cascadeless или recoverable свойства без доп. механизмов) \autocite{Silberschatz}
\end{itemize}

Чтобы обеспечить recoverability (восстанавливаемость) и избежать каскадных откатов можно \autocite{Silberschatz, ElmasriNavathe}:
\begin{itemize}
    \item Можно откладывать запись в базу до завершения всех операций (так называемый deferred write)
    \item Можно применять ограниченные блокировки на записи чтоб предотвратить чтение незафикшенных данныхх
    \item Можно использовать commit dependencies (зависимости фиксации) - транзакция может быть зафиксирован только после фиксации другой от которой она зависит
\end{itemize}

\subparagraph{Пролема фантомов} ~\\

Предикатный запрос - это SQL-запрос, выбирающиц не крентретные строки по первичному ключу, а множество строк по заданному условию. Примеры:
\begin{lstlisting}[language=SQL]
    SELECT * FROM employees WHERE salary > 100000;
    SELECT * FROM orders WHERE order_date BETWEEN '2024-01-01' AND '2024-03-01';       
\end{lstlisting}

Теперь представим что одна транзакция $T_1$ выполняет такой запрос, а другая транзакция $T_2$ вставляет новую строку котоаря удовлетворяет томуже условию. Если $T_1$ повторит запрос в рамках своей-же транзакции то она увидит новую строку, которой не было ранее, и это нарушит изоляцию. Это явление называется \textbf{фантомным чтением (phantom read)}

Классический протокол управления параллелизмос на основе таймштампов контроллироет последовательность операций только на уровне кортежей (tuples). То есть проверяются конфликты между отдельными строками, а не между какими-то множестввами строк выбранными по предикату.
То есть система может не знать что изменение (вставка, удаление) новой строки затрагивает предикат уже выполненного запроса в другой транзакции. В результате транзакция может дважды выполнить оин и тот же предикатный запрос и получить разные результаты (аномалия фантома), и при этом никаких явныхх конфликтов чтения/записи отдельных строк не произойдет, и система это не заметит.

Ограничение здесь - только кортежи. Протокол, как ранее было описано, отслеживает два значения - $W_{\text{timestamp}}(Q)$ и $R_{\text{timestamp}}(Q)$ для каждого обьекта $Q$. Если $Q$ - это строка таблицы, то все управление конфликтами сводится к строкам. Но предикатные запросы потенциально работают и со всем множестом строк, которые еще не существуют, и таймштамп-протокол просто не может их учесть пока они не будут вставлены - и это его принципиальное ограничение.

Чтобы избежать фантомов, надо учитывать не только tuples, но и структуру таблицы в целом и еще индексные узлы. Почему?
Потому что предикатный запрос фактически взаимодействует с следующим:
\begin{itemize}
    \item множество строк которые удовлетворяют условию
    \item интервалы значений, которые проверяются (например \texttt{WHERE salary $>$ 100000} — это диапазон)
    \item индексы, которые используются для ускорения поиска
\end{itemize}

В протоколах блокировок (типа 2PL) эта проблема решается путём блокировки интервалов в индексах (index-range locking). Аналогично и в timestamp-протоколе: если распространить таймштампы на индексные страницы, можно отслеживать изменения предикатных множеств \autocite{Silberschatz, ElmasriNavathe}

\subsubsection{Управление блокировками в СУБД}

\paragraph{1. Архитектура управления блокировками} ~\\

Современные СУБД предьявляют высокие требования к параллельно обработке данных и целостности информации. Именно в связи с этим одним из главных компонинтов большинства СУБД является \textbf{менеджер блокировок (Lock Manager)} \autocite{Silberschatz}. Он отвечает за согласовывание доступа к данным между транзакциями и предотвращение конфликтов.

\subparagraph{Lock Table - таблица блокировок} ~\\
 Lock Manager поддерживает специальную внутреннюю структуру данынх - \textbf{таблицу блокировок (lock table)}, которая хранит информацию о текущим состоянии блокировок. Каждач запись в таблице блокировок хранит следующие вещи:
 \begin{itemize}
     \item Ресурс (resource) — объект, к которому применяется блокировка (строка, страница, таблица и т.п.)
     \item Идентификатор транзакции (transaction ID) — та транзакция, которая удерживает или ожидает блокировку
     \item Тип блокировки (S (shared), X (exclusive), IS, IX и т.д)
     \item Состояние (активна ли блокировка или транзкация находится в очереди ожидания)
 \end{itemize}
 То есть lock table это является "центральным реестром" всех блокировок (активных и ждущих) которйы постоянно обновляется по мере выолнения транзакций.

\subparagraph{Структуры данных: хеш-таблицы и списки ожидания} ~\\
 Для эфиктивного поиска блокировок по идентификатору ресурса или транзакции большинство СУБД используют хеш-таблицы. Например, в PostgreSQL bcgjkmpetncz механизм хеширования lock-tag'ов (уник. идентификаторов блокировок), где каждый тег состоит из инфырмации о типе рисурса, обьекте и контексте (например таблица+строка+БД)
 Для обработки ситуаций когда несколько транзакций претендуют на один и тот же ресурс, менеджер ожидания юзает \textbf{очереди ожидания (wait queues)}. Каждая запись в очереди содержит ссылку на транзакци, ожидаемую блокировку, реэим блокировки. И сразу как тольк ресурс освобождается, менеджер проверяет какие из ожидающших транзакций могут быть разблокированы в соответствии с таблицей совместимости (см. далее).

\subparagraph{Таблица совместимости блокировок} ~\\
 Чтобы определить можно ли выдать блокировку новой транзакции, Lock Manager использует \textbf{таблицу совместимости блокировок (lock compatibility matrix)}. Эта таблица содержит информацию о допустимости наложения разных типов блокировок на один и тот же ресурс (какие блокировки могут быть установлены одновременно). Таблица совместимости блокирровок выглядит следующим образом \autocite{Silberschatz}:
 
 \begin{table}[H]
    \centering
    \begin{tabular}{|c|c|c|c|c|c|}
        \hline
        \textbf{Запрос / Установлена} & \textbf{IS} & \textbf{IX} & \textbf{S} & \textbf{SIX} & \textbf{X} \\
        \hline
        \textbf{IS} & Да & Да & Да & Да & Нет \\
        \hline
        \textbf{IX} & Да & Да & Нет & Нет & Нет \\
        \hline
        \textbf{S} & Да & Нет & Да & Нет & Нет \\
        \hline
        \textbf{SIX} & Да & Нет & Нет & Нет & Нет \\
        \hline
        \textbf{X} & Нет & Нет & Нет & Нет & Нет \\
        \hline
    \end{tabular}
    \caption{Матрица совместимости блокировок}
 \end{table}

 Каждая строка — это тип запрашиваемой блокировки, а каждый столбец — это тип уже установленной блокировки.
 На основании этой таблицы менеджер блокировок решает либо выдать блокировку немедленно, либо поставить транзакцию в очередь ожидания.
 То есть, исходя из таблицы, если на обьекте уже стоит \texttt{IS}, то можно установить \texttt{S}. Если на обьекте стоит \texttt{S}, то не льзя установить \texttt{X}.

 Рассмотрим назначение комбинированной блокировки \texttt{SIX}:
 \texttt{SIX} (Shared and Intention Exclusive) - комбинированный режим который одновременно удерживает разделяемую блокировку на уровне узла (например таблицы), и заявляет, что будут эксклюзивные блокировки ниже (например на строках).
 \begin{lstlisting}[language=SQL]
    LOCK TABLE employees IN SHARE MODE;
    UPDATE employees SET salary = salary + 1000 WHERE department = 'IT';   
 \end{lstlisting}

 Первая строка - \texttt{S} или \texttt{SIX}, вторая - \texttt{X} на строках. 
 Чтобы не накладывать \texttt{S} \+ \texttt{IX} одновременно (что не совместимо с \texttt{S} другой транзакции), используется \texttt{SIX} как оптимизировнный и безопасный способ

\subparagraph{Хеш-функции и внутренние идентификаторы} ~\\

 В PostgreSQL для управления блокировками используется структура LOCKTAG, которая уникально идентифицирует каждый блокируемый объект. Эта структура включает в себя поля \texttt{locktag\_field1}, \texttt{locktag\_field2}, \texttt{locktag\_field3}, \texttt{locktag\_field4}, \texttt{locktag\_type}, \texttt{locktag\_lockmethodid} \autocite{PostgreSQLlockh1, PostgreSQLlockh2}
 Эти поля позволяют идентифицировать различные объекты. Тип объекта определяется полем \texttt{locktag\_type}, которое может принимать значения из перечисления \texttt{LockTagType}, например \texttt{LOCKTAG\_RELATION} для всей таблицы или \texttt{LOCKTAG\_TUPLE} для конкретной строки.
 
 Для управления блокировками PostgreSQL использует хеш-таблицы. Функция \texttt{LockTagHashCode} вычисляет хеш-код для заданного \texttt{LOCKTAG} и позволяет быстро находить и устанавливать блокировки. Этот хеш-код используется для определения раздела хеш-таблицы, в котором хранится информация о блокировке. \autocite{PostgreSQLlockc1, PostgreSQLlockc2}

\paragraph{2. Поддержка блокировок в различных СУБД} ~\\
\textit{~Coming soon}

\paragraph{3. Взаимодействие с журналом транзакций и буфером} ~\\
\textit{~Coming soon}

\paragraph{4. Таблицы блокировок и внутренние представления} ~\\
\textit{~Coming soon}

\paragraph{5. Управление конфликтами блокировок} ~\\
\textit{~Coming soon}

\paragraph{6. Администрирование и отладка} ~\\
\textit{~Coming soon}

\paragraph{7. Подходы к оптимизации управления блокировками} ~\\
\textit{~Coming soon}

\paragraph{8. Сравнение: централизованное и распределённое управление} ~\\
%????????????????
\textit{~Coming soon}















\subsubsection{Разрешение конфликтов, оптимизация (\textit{Coming soon})}

\textit{~Coming soon}





\subsection{Контроль целостности на уровне СУБД (\textit{Coming soon})}
%Проверить подраздел "ссылочная целостность", мб его вставить сюда
\textit{~Coming soon}





\subsection{Правила (триггеры) (\textit{Coming soon})}

\textit{~Coming soon}





\subsection{События (\textit{Coming soon})}

\textit{~Coming soon}





\subsection{Журналирование и резервное копирование (\textit{Coming soon})}

\textit{~Coming soon (WAL, PITR, репликация и тд)}
























\subsection{OLD. Ссылочная целостность}

Ссылочная целостность. Ссылочная целостность относится непосредственно к связям между таблицами. Если кратко, то ссылочная целостность должна отвечать на вопрос: что будет со строками одной таблицы, если в связанной таблице выполняется какая-либо операция модификации? Для того чтобы понять логику ссылочной целостности, будем считать таблицу главной в паре связанных таблиц, если она содержит первичный ключ, с помощью которого осуществляется связь. Вторую таблицу будем считать подчиненной таблицей. Теперь выделим три вида операции над связанными таблицами: удаление из главной таблицы, обновление строк главной таблицы, вставка в подчиненную таблицу.

\begin{enumerate}
    \item Удаление строк из главной таблицы. Если удаляемая строка не связана со строками другой таблицы, то удалять можно без всяких последствий. Но если удаляемая строка связана со строками другой таблицы, то надо подумать, что же будет с этими строками. Просто оставить их без изменения нельзя, т. к. не понятно, как быть со значениями внешних ключей. В принципе, возможны следующие четыре сценария, поддерживаемые основными СУБД:
        \begin{itemize}
            \item строки из подчиненной таблицы должны быть удалены вместе со связанными строками из подчиненной таблицы. Такой механизм называется каскадированием;
            \item если удаляемая строка из главной таблицы связана со сроками из подчиненной таблицы, то такая операция удаления должна быть отвергнута. Данный механизм наиболее безопасен и предпочтителен при построении информационной системы;
            \item если строка в подчиненной таблице связана с удаляемой строкой в главной таблице, то внешнему ключу следует присвоить значение NULL;
            \item если строка в подчиненной таблице связана с удаляемой строкой в главной таблице, то внешнему ключу следует присвоить значение, принятое по умолчанию.
        \end{itemize}
    
    \item Обновление строк из главной таблицы. Если обновляемая строка не связана со строками другой таблицы или обновляются столбцы, не от- носящиеся к первичному ключу, то обновлять можно без всяких последствий. Но если обновляемая строка связана со строками другой таблицы и обновляется первичный ключ, то здесь, как и в предыдущем случае, возможны четыре сценария:
        \begin{itemize}
            \item первичные ключи из главной таблицы обновляются вместе с внешними ключами подчиненной таблицы. Как и в случае с подобной операцией удаления, этот механизм называется каскадированием;
            \item если обновляемая строка связана с какой-либо строкой подчиненной таблицы, то операция обновления должна быть отвергнута;
            \item если строка в подчиненной таблице связана с обновляемой строкой в главной таблице, то внешнему ключу следует присвоить значение NULL;
            \item если строка в подчиненной таблице связана с обновляемой строкой в главной таблице, то внешнему ключу следует присвоить значение, принятое по умолчанию.
        \end{itemize}

    \item Вставка строк в подчиненную таблицу. Здесь возможны следующие механизмы.
        \begin{itemize}
            \item Строка в подчиненной таблице вставляется вместе со строкой в главной таблице. Здесь важно иметь в виду, что в главной таблице для всех столбцов должны быть определены значения по умолчанию. Последовательность добавления такая: вначале добавляется строка в главную таблицу и определяется значение первичного ключа. Затем добавляется строка в подчиненную таблицу, в которой значению внешнего ключа присваивается значение первичного клю- ча в главной таблице.
            \item Строка в подчиненную таблицу добавляется только при условии, что соответствующая ей строка в главной таблице уже существует.
            \item При добавлении строки в подчиненную таблицу внешнему ключу присваивается значение NULL.
            \item При добавлении строки в подчиненную таблицу внешнему ключу присваивается значение по умолчанию.
        \end{itemize}
\end{enumerate}

В некоторых простых СУБД отсутствует возможность устанавливать связи между таблицами и, таким образом, поддерживать ссылочную целостность. В этом случае поддержание ссылочной целостности полностью ложится на плечи программиста. Другими словами, связь между таблицами должна быть реализована на уровне прикладного программного обеспечения.

\paragraph{Декларативная и процедурная ссылочные целостности} ~\\

Различают два способа реализации ограничений целостности:

\begin{itemize}
    \item Декларативная поддержка ограничений целостности.
    \item Процедурная поддержка ограничений целостности.
\end{itemize}

\begin{grayquote}
    \textbf{Декларативная поддержка ограничений целостности} заключается в определении ограничений средствами языка определения данных (DDL - Data Definition Language). Обычно средства декларативной поддержки целостности (если они имеются в СУБД) определяют ограничения на значения доменов и атрибутов, целостность сущностей (потенциальные ключи отношений) и ссылочную целостность (целостность внешних ключей). Декларативные ограничения целостности можно использовать при создании и модификации таблиц средствами языка DDL или в виде отдельных утверждений (ASSERTION).
\end{grayquote}

Например, следующий оператор создает таблицу PERSON и определяет для нее некоторые ограничения целостности:

\begin{verbatim}
CREATE TABLE PERSON
  (Pers_Id INTEGER PRIMARY KEY,
  Pers_Name CHAR(30) NOT NULL,
  Dept_Id REFERENCES DEPART(Dept_Id) ON UPDATE CASCADE ON DELETE CASCADE);
\end{verbatim}

После выполнения оператора для таблицы PERSON будут объявлены следующие ограничения целостности:

\begin{itemize}
    \item Поле Pers\_Id образует потенциальный ключ отношения.
    \item Поле Pers\_Name не может содержать null-значений.
    \item Поле Dept\_Id является внешней ссылкой на родительскую таблицу DEPART, причем, при изменении или удалении строки в родительской таблице каскадно должны быть внесены соответствующие изменения в дочернюю таблицу.
\end{itemize}

\begin{grayquote}
    \textbf{Процедурная поддержка ограничений целостности} заключается в использовании триггеров и хранимых процедур.
\end{grayquote}

Не все ограничения целостности можно реализовать декларативно. Примером такого ограничения может служить требование из примера 1, утверждающее, что поле Dept\_Kol таблицы DEPART должно содержать количество сотрудников, реально числящихся в подразделении. Для реализации этого ограничения необходимо создать триггер, запускающийся при вставке, модификации и удалении записей в таблице PERSON, который корректно изменяет значение поля Dept\_Kol. Например, при вставке в таблицу PERSON новой строки, триггер увеличивает на единицу значение поля Dept\_Kol, а при удалении строки - уменьшает. Заметим, что при модификации записей в таблице PERSON могут потребоваться даже более сложные действия. Действительно, модификация записи в таблице PERSON может заключаться в том, что мы переводим сотрудника из одного отдела в другой, меняя значение в поле Dept\_Id. При этом необходимо в старом подразделении уменьшить количество сотрудников, а в новом - увеличить \autocite{TransCit}.

\paragraph{Внешний ключ} ~\\

\begin{grayquote}
    \textbf{Внешний ключ} – это ограничение целостности, в соответствии с которым множество значений внешнего ключа является подмножеством значений первичного или уникального ключа родительской таблицы \autocite{Karpova2009}.
\end{grayquote}

Ограничение целостности по внешнему ключу проверяется в двух случаях \autocite{Karpova2009}:

\begin{itemize}
    \item при добавлении записи в подчинённую таблицу СУБД проверяет, что в родительской таблице есть запись с таким же значением первичного ключа;
    \item при удалении записи из родительской таблицы СУБД проверяет, что в подчинённой таблице нет записей с таким же значением внешнего ключа.
\end{itemize}

\paragraph{Способы поддержания ссылочной целостности} ~\\
СУБД имеют механизм автоматического поддержания ссылочной целостности. Любая операция, изменяющая данные в таблице, вызывает автоматическую проверку ссылочной целостности. При этом \autocite{WikiLink}:

\begin{itemize}
    \item При операции добавления записи автоматически проверяется, ссылаются ли внешние ключи в этой записи на существующие записи в заявленных при описании связанных таблицах. Если выясняется, что операция приведёт к появлению некорректных ссылок, она не выполняется — система возвращает ошибку.
    
    \item При операции редактирования записи проверяется:
    \begin{itemize}
        \item если изменяется её первичный ключ и на данную запись имеются ссылки, то операция редактирования завершается с ошибкой;
        \item если изменяется какой-то из внешних ключей, хранящихся в этой записи, и после изменения внешний ключ будет ссылаться на несуществующую запись, то операция редактирования завершается с ошибкой.
    \end{itemize}
    
    \item При операции удаления записи проверяется, нет ли на неё ссылок. Если ссылки имеются, то возможно три варианта дальнейших действий (фактически выполняемый зависит от СУБД и от выбора программиста, который он должен сделать при описании связи):
    \begin{itemize}
        \item Запрет — удаление блокируется и возвращается ошибка.
        \item Каскадное удаление — в одной транзакции производится удаление данной записи и всех записей, ссылающихся на данную. Если на удаляемые записи также есть ссылки и настройки также требуют удаления, то каскадное удаление продолжается дальше. Таким образом, после удаления данной записи в базе не остаётся ни одной записи, прямо или косвенно ссылающейся на неё. Если хотя бы одну из ссылающихся записей удалить не получается (либо для неё настроен запрет, либо происходит какая-либо ещё ошибка), то все удаления запрещаются.
        \item Присвоение NULL — во все внешние ключи записей, ссылающихся на данную, записывается маркер NULL. Если хотя бы для одной из ссылающихся записей это невозможно (например, если поле внешнего ключа описано как NOT NULL), то удаление запрещается.
    \end{itemize}
\end{itemize}

\subsection{OLD. Правила (триггеры)}
Триггеры являются одной из разновидностей хранимых процедур. Их исполнение происходит при выполнении для таблицы какого-либо оператора языка манипулирования данными (DML). Триггеры используются для проверки целостности данных, а также для отката транзакций.


Триггер представляет собой специальный тип хранимых процедур, запускаемых сервером автоматически при попытке изменения данных в таблицах, с которыми триггеры связаны. Каждый триггер привязывается к конкретной таблице. Все производимые им модификации данных рассматриваются как одна транзакция. В случае обнаружения ошибки или нарушения целостности данных происходит откат этой транзакции. Тем самым внесение изменений запрещается. Отменяются также все изменения, уже сделанные триггером.


Триггер представляет собой весьма полезное и в то же время опасное средство. Так, при неправильной логике его работы можно легко уничтожить целую базу данных, поэтому триггеры необходимо очень тщательно отлаживать.


В отличие от обычной подпрограммы, триггер выполняется неявно в каждом случае возникновения триггерного события, к тому же он не имеет аргументов. Приведение его в действие иногда называют запуском триггера \autocite{IntuitTrigg}

\paragraph{Цели использования правил} ~\\

С помощью триггеров достигаются следующие цели \autocite{IntuitTrigg}:
\begin{itemize}
    \item проверка корректности введенных данных и выполнение сложных ограничений целостности данных, которые трудно, если вообще возможно, поддерживать с помощью ограничений целостности, установленных для таблицы;
    \item выдача предупреждений, напоминающих о необходимости выполнения некоторых действий при обновлении таблицы, реализованном определенным образом;
    \item накопление аудиторской информации посредством фиксации сведений о внесенных изменениях и тех лицах, которые их выполнили;
    \item поддержка репликации.
\end{itemize}

\paragraph{Способы задания, моменты выполнения} ~\\

Создает триггер только владелец базы данных. Это ограничение позволяет избежать случайного изменения структуры таблиц, способов связи с ними других объектов и т.п.


Основной формат команды CREATE TRIGGER показан ниже:
\begin{verbatim}
<Определение_триггера>::=
  CREATE TRIGGER имя_триггера
  BEFORE | AFTER <триггерное_событие>
  ON <имя_таблицы>
  [REFERENCING
    <список_старых_или_новых_псевдонимов>]
  [FOR EACH { ROW | STATEMENT}]
  [WHEN(условие_триггера)]
  <тело_триггера>
\end{verbatim}

Триггерные события состоят из вставки, удаления и обновления строк в таблице. В последнем случае для триггерного события можно указать конкретные имена столбцов таблицы.

\begin{grayquote}
    \textbf{Триггер} – это процедура БД, которая привязана к конкретной таблице и вызывается автоматически при наступлении определённого события (добавления, удаления или модификации данных этой таблицы).
\end{grayquote}

В отличие от обычной подпрограммы, триггер выполняется неявно в каждом случае возникновения триггерного события, к тому же он не имеет аргументов. Приведение его в действие иногда называют запуском триггера.


Время запуска триггера определяется с помощью ключевых слов BEFORE ( триггер запускается до выполнения связанных с ним событий) или AFTER (после их выполнения).


Выполняемые триггером действия задаются для каждой строки ( FOR EACH ROW ), охваченной данным событием, или только один раз для каждого события ( FOR EACH STATEMENT ).


Обозначение <список\_старых\_или\_новых\_псевдонимов> относится к таким компонентам, как старая или новая строка ( OLD / NEW ) либо старая или новая таблица ( OLD TABLE / NEW TABLE ). Ясно, что старые значения не применимы для событий вставки, а новые – для событий удаления \autocite{IntuitTrigg}.

\subsection{OLD. События}

\paragraph{Назначение механизма событий} ~\\

Механизм событий в базе данных (database events) позволяет прикладным программам и серверу базы данных уведомлять другие программы о наступлении в базе данных определенного события и тем самым синхронизировать их работу \autocite{OSP}.

\paragraph{Сигнализаторы событий. Типы уведомлений о происхождении события. Компоненты механизма событий} ~\\

Операторы языка SQL, обеспечивающие уведомление, часто называют сигнализаторами событий в базе данных (database event alerters). Функции управления событиями целиком ложатся на сервер базы данных.


Механизм событий используется следующим образом. Вначале в базе данных для каждого события создается флажок, состояние которого будет оповещать прикладные программы о том, что некоторое событие имело место (оператор CREATE DBEVENT - СОЗДАТЬ СОБЫТИЕ). Далее во все прикладные программы, на ход выполнения которых может повлиять это событие, включается оператор REGISTER DBEVENT (ЗАРЕГИСТРИРОВАТЬ СОБЫТИЕ), который оповещает сервер базы данных, что данная программа заинтересована в получении сообщения о наступлении события. Теперь любая прикладная программа или процедура базы данных может вызвать событие оператором RAISE DBEVENT (ВЫЗВАТЬ СОБЫТИЕ). Как только событие произошло, каждая зарегистрированная программа может получить его, для чего должна запросить очередное сообщение из очереди событий (оператор GET DBEVENT - ПОЛУЧИТЬ СОБЫТИЕ) и запросить информацию о событии, в частности, его имя (оператор SQL INQUIRE\_SQL) \autocite{OSP}.
